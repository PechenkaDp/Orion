~1) docker-compose.monitoring.yml;~

version: '3.8'

networks:
  monitoring:
    driver: bridge

volumes:
  prometheus_data: {}
  grafana-data: {}

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--web.enable-lifecycle'
    ports:
      - 9090:9090
    networks:
      - monitoring

  grafana:
    image: grafana/grafana-oss:latest
    container_name: grafana
    ports:
      - '3000:3000'
    volumes:
      - grafana-data:/var/lib/grafana
    restart: unless-stopped
    networks:
      - monitoring

~2) docker-compose.yml;~

version: '3.8'

networks:
  monitoring:
    driver: bridge

volumes:
  prometheus_data: {}
  grafana-data: {}
  etc_influxdb_data: {}
  influxdb_data: {}

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--web.enable-lifecycle'
    ports:
      - 9090:9090
    networks:
      - monitoring

  grafana:
    image: grafana/grafana-oss:latest
    container_name: grafana
    ports:
      - '3000:3000'
    volumes:
      - grafana-data:/var/lib/grafana
    restart: unless-stopped
    networks:
      - monitoring

  influxdb:
    image: influxdb:latest
    container_name: influxdbDj
    ports:
      - "8086:8086"
    volumes:
      - etc_influxdb_data:/etc/influxdb2
      - influxdb_data:/var/lib/influxdb2
    networks:
      - monitoring
  telegraf:
    image: telegraf:latest
    container_name: telegrafDjango
    restart: always
    networks:
      - monitoring
    depends_on:
      - influxdb
    volumes:
      - ./telegraf/telegraf.conf:/etc/telegraf/telegraf.conf:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - /sys:/rootfs/sys:ro
      - /proc:/rootfs/proc:ro
      - /etc:/rootfs/etc:ro
    environment:
      HOST_PROC: /rootfs/proc
      HOST_SYS: /rootfs/sys
      HOST_ETC: /rootfs/etc
    privileged: true

~3) locust.conf;~

host = http://127.0.0.1:8000/
users = 5
spawn-rate = 30
run-time = 1m

~4) main.py;~

from faker import Faker
from locust import HttpUser, SequentialTaskSet, TaskSet, task, constant_throughput

fake = Faker('ru_RU')

departments = ["Производственный отдел", "Отдел безопасности", "Административный отдел", "ИТ-отдел", "Логистика"]
departments_added = []

safety_items = ["Защитная каска", "Респиратор", "Защитные очки", "Защитные перчатки", "Спецодежда"]
safety_items_added = []

document_types = ["Инструкция", "Регламент", "Положение", "Приказ", "Распоряжение"]
document_types_added = []

hazard_types = ["Химическая опасность", "Механическая опасность", "Электрическая опасность",
                "Пожарная опасность", "Радиационная опасность"]
hazard_types_added = []

inspection_types = ["Плановая", "Внеплановая", "Текущая", "Комплексная", "Целевая"]
inspection_types_added = []


class GetAuthRegister(TaskSet):
    @task
    def get_auth(self):
        response = self.client.get("/")
        if response.status_code != 200:
            response.failure("Не удалось загрузить страницу авторизации")

    @task
    def get_register(self):
        response = self.client.get("/admin/")
        if response.status_code != 200:
            response.failure("Не удалось загрузить страницу администратора")


class AdminLoginAndActions(TaskSet):
    def on_start(self):
        response = self.client.get("/")
        if "csrftoken" in response.cookies:
            csrftoken = response.cookies["csrftoken"]
            self.client.post("/", {
                "username": "admin",
                "password": "admin",
                "csrfmiddlewaretoken": csrftoken
            }, headers={"Referer": "http://127.0.0.1:8000/"})
        else:
            self.interrupt()

    @task
    def add_department(self):
        response = self.client.get("/admin/core/department/add/")

        if "csrftoken" in response.cookies:
            csrftoken = response.cookies["csrftoken"]

            department_name = departments[len(departments_added) % len(departments)]

            if department_name in departments_added:
                return

            self.client.post("/admin/core/department/add/", {
                "name": department_name,
                "description": fake.text(max_nb_chars=100),
                "csrfmiddlewaretoken": csrftoken
            }, headers={"Referer": "http://127.0.0.1:8000/admin/core/department/add/"})

            departments_added.append(department_name)

    @task
    def add_safety_item(self):
        response = self.client.get("/admin/core/ppeitem/add/")

        if "csrftoken" in response.cookies:
            csrftoken = response.cookies["csrftoken"]

            item_name = safety_items[len(safety_items_added) % len(safety_items)]

            if item_name in safety_items_added:
                return

            self.client.post("/admin/core/ppeitem/add/", {
                "name": item_name,
                "category": "Защита " + fake.word(),
                "standard_issue_period": fake.random_int(min=30, max=365),
                "csrfmiddlewaretoken": csrftoken
            }, headers={"Referer": "http://127.0.0.1:8000/admin/core/ppeitem/add/"})

            safety_items_added.append(item_name)

    @task
    def view_dashboard(self):
        self.client.get("/dashboard/")


class DocumentActions(TaskSet):
    def on_start(self):
        response = self.client.get("/")
        if "csrftoken" in response.cookies:
            csrftoken = response.cookies["csrftoken"]
            self.client.post("/", {
                "username": "admin",
                "password": "admin",
                "csrfmiddlewaretoken": csrftoken
            }, headers={"Referer": "http://127.0.0.1:8000/"})
        else:
            self.interrupt()

    @task
    def add_document(self):
        response = self.client.get("/documents/create/")

        if "csrfmiddlewaretoken" in response.text:
            csrftoken = response.text.split('name="csrfmiddlewaretoken" value="')[1].split('"')[0]

            doc_type = document_types[len(document_types_added) % len(document_types)]

            if doc_type in document_types_added:
                return

            self.client.post("/documents/create/", {
                "title": f"{doc_type} о {fake.word()}",
                "document_type": doc_type,
                "description": fake.text(max_nb_chars=150),
                "publish_date": fake.date(),
                "effective_date": fake.date(),
                "version": f"1.{fake.random_int(min=0, max=9)}",
                "author": fake.name(),
                "is_active": "on",
                "csrfmiddlewaretoken": csrftoken
            })

            document_types_added.append(doc_type)

    @task
    def view_documents(self):
        self.client.get("/documents/")


class RiskAndHazardActions(TaskSet):
    def on_start(self):
        response = self.client.get("/")
        if "csrftoken" in response.cookies:
            csrftoken = response.cookies["csrftoken"]
            self.client.post("/", {
                "username": "admin",
                "password": "admin",
                "csrfmiddlewaretoken": csrftoken
            }, headers={"Referer": "http://127.0.0.1:8000/"})
        else:
            self.interrupt()

    @task
    def add_hazard(self):
        response = self.client.get("/admin/core/hazard/add/")
        if "csrftoken" in response.cookies:
            csrftoken = response.cookies["csrftoken"]

            hazard_type = hazard_types[len(hazard_types_added) % len(hazard_types)]

            if hazard_type in hazard_types_added:
                return

            self.client.post("/admin/core/hazard/add/", {
                "name": hazard_type,
                "description": fake.text(max_nb_chars=150),
                "category": hazard_type.split()[0],
                "csrfmiddlewaretoken": csrftoken
            }, headers={"Referer": "http://127.0.0.1:8000/admin/core/hazard/add/"})

            hazard_types_added.append(hazard_type)

    @task
    def view_risks(self):
        self.client.get("/risks/")


class InspectionActions(TaskSet):
    def on_start(self):
        response = self.client.get("/")
        if "csrftoken" in response.cookies:
            csrftoken = response.cookies["csrftoken"]
            self.client.post("/", {
                "username": "admin",
                "password": "admin",
                "csrfmiddlewaretoken": csrftoken
            }, headers={"Referer": "http://127.0.0.1:8000/"})
        else:
            self.interrupt()

    @task
    def add_inspection(self):
        response = self.client.get("/inspections/create/")

        if "csrfmiddlewaretoken" in response.text:
            csrftoken = response.text.split('name="csrfmiddlewaretoken" value="')[1].split('"')[0]

            inspection_type = inspection_types[len(inspection_types_added) % len(inspection_types)]

            if inspection_type in inspection_types_added:
                return

            self.client.post("/inspections/create/", {
                "title": f"Проверка {fake.word()} ({inspection_type})",
                "inspection_type": inspection_type,
                "department": "1",
                "start_date": fake.date_time(),
                "status": "new",
                "description": fake.text(max_nb_chars=150),
                "csrfmiddlewaretoken": csrftoken
            })

            inspection_types_added.append(inspection_type)

    @task
    def view_inspections(self):
        self.client.get("/inspections/")


class WebsiteUser(HttpUser):
    tasks = [
        GetAuthRegister,
        AdminLoginAndActions,
        DocumentActions,
        RiskAndHazardActions,
        InspectionActions
    ]
    wait_time = constant_throughput(1)

~5) manage.py;~

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'OrionWorkSec.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


~6) prometheus.yml;~

global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'django_app'
    metrics_path: '/prometheus/metrics'
    static_configs:
      - targets: ['host.docker.internal:8000']

~7) admin.py;~

from django.contrib import admin
from django.utils.html import format_html
from django.contrib.auth.admin import UserAdmin
from django.contrib.auth.models import User
from import_export.admin import ImportExportModelAdmin, ImportExportActionModelAdmin
from import_export.formats import base_formats

from .models import (
    Department, Employee, PPEItem, PPERequest, PPEIssuance,
    Document, InstructionType, Instruction, InstructionParticipant,
    Equipment, EquipmentMaintenance, Hazard, Risk, RiskMitigationMeasure,
    Inspection, InspectionFinding, Incident, IncidentVictim, SafetyTask,
    WorkplaceAssessment, MedicalExamination, Notification, UserLog
)
from .resources import (
    UserResource, DepartmentResource, EmployeeResource, PPEItemResource,
    PPERequestResource, DocumentResource, InstructionTypeResource,
    InstructionResource, EquipmentResource, HazardResource, RiskResource,
    InspectionResource, IncidentResource, MedicalExaminationResource
)

# Настройка админки для пользователей
class EmployeeInline(admin.StackedInline):
    model = Employee
    can_delete = False
    verbose_name_plural = 'Информация о сотруднике'
    fields = ('department', 'position', 'role', 'hire_date', 'medical_exam_date', 'next_medical_exam_date')


class CustomUserAdmin(UserAdmin, ImportExportModelAdmin):
    resource_class = UserResource
    inlines = (EmployeeInline,)
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    list_display = ('username', 'email', 'first_name', 'last_name', 'get_role', 'get_department', 'is_active')
    list_filter = ('employee__role', 'employee__department', 'is_active')
    search_fields = ('username', 'email', 'first_name', 'last_name', 'employee__position')

    def get_role(self, obj):
        try:
            return obj.employee.get_role_display()
        except Employee.DoesNotExist:
            return '-'

    get_role.short_description = 'Роль'

    def get_department(self, obj):
        try:
            return obj.employee.department.name if obj.employee.department else '-'
        except Employee.DoesNotExist:
            return '-'

    get_department.short_description = 'Подразделение'


# Перерегистрируем модель User с нашим CustomUserAdmin
admin.site.unregister(User)
admin.site.register(User, CustomUserAdmin)


# Админка для подразделений
@admin.register(Department)
class DepartmentAdmin(ImportExportModelAdmin):
    resource_class = DepartmentResource
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    list_display = ('name', 'parent', 'get_employees_count')
    search_fields = ('name', 'description')
    list_filter = ('parent',)

    def get_employees_count(self, obj):
        return obj.employees.count()

    get_employees_count.short_description = 'Количество сотрудников'


# Админка для сотрудников
@admin.register(Employee)
class EmployeeAdmin(ImportExportModelAdmin):
    resource_class = EmployeeResource
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    list_display = ('__str__', 'position', 'department', 'role', 'hire_date', 'next_medical_exam_status')
    list_filter = ('role', 'department', 'hire_date')
    search_fields = ('user__first_name', 'user__last_name', 'position', 'personal_id_number')
    date_hierarchy = 'hire_date'

    def next_medical_exam_status(self, obj):
        if not obj.next_medical_exam_date:
            return format_html('<span style="color: gray;">Не указано</span>')

        from django.utils import timezone
        if obj.next_medical_exam_date < timezone.now().date():
            return format_html('<span style="color: red; font-weight: bold;">Просрочен ({})</span>',
                               obj.next_medical_exam_date.strftime('%d.%m.%Y'))
        else:
            return format_html('<span style="color: green;">{}</span>',
                               obj.next_medical_exam_date.strftime('%d.%m.%Y'))

    next_medical_exam_status.short_description = 'Следующий медосмотр'


# Админка для СИЗ
@admin.register(PPEItem)
class PPEItemAdmin(ImportExportModelAdmin):
    resource_class = PPEItemResource
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    list_display = ('name', 'category', 'standard_issue_period', 'manufacturer')
    list_filter = ('category',)
    search_fields = ('name', 'category', 'description', 'manufacturer', 'supplier')


# Админка для заявок на СИЗ
class PPEIssuanceInline(admin.TabularInline):
    model = PPEIssuance
    extra = 0
    fields = ('issue_date', 'quantity', 'issued_by', 'expected_return_date', 'actual_return_date')


@admin.register(PPERequest)
class PPERequestAdmin(ImportExportModelAdmin):
    resource_class = PPERequestResource
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    list_display = ('id', 'employee', 'ppe_item', 'quantity', 'request_date', 'status')
    list_filter = ('status', 'request_date', 'ppe_item__category')
    search_fields = ('employee__user__last_name', 'employee__user__first_name', 'ppe_item__name')
    date_hierarchy = 'request_date'
    inlines = [PPEIssuanceInline]


# Админка для документов
@admin.register(Document)
class DocumentAdmin(ImportExportModelAdmin):
    resource_class = DocumentResource
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    list_display = ('title', 'document_type', 'publish_date', 'effective_date', 'expiry_date', 'is_active')
    list_filter = ('document_type', 'is_active', 'publish_date')
    search_fields = ('title', 'description', 'author')
    date_hierarchy = 'publish_date'


# Админка для типов инструктажей
@admin.register(InstructionType)
class InstructionTypeAdmin(ImportExportModelAdmin):
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    resource_class = InstructionTypeResource
    list_display = ('name', 'period_days')
    search_fields = ('name', 'description')


# Админка для инструктажей
class InstructionParticipantInline(admin.TabularInline):
    model = InstructionParticipant
    extra = 0
    fields = ('employee', 'status', 'test_result')


@admin.register(Instruction)
class InstructionAdmin(ImportExportModelAdmin):
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    resource_class = InstructionResource
    list_display = ('instruction_date', 'instruction_type', 'department', 'instructor', 'get_participants_count',
                    'next_instruction_date')
    list_filter = ('instruction_type', 'instruction_date', 'department')
    search_fields = ('instructor__last_name', 'instructor__first_name', 'location')
    date_hierarchy = 'instruction_date'
    inlines = [InstructionParticipantInline]

    def get_participants_count(self, obj):
        return obj.participants.count()

    get_participants_count.short_description = 'Количество участников'


# Админка для оборудования
@admin.register(Equipment)
class EquipmentAdmin(ImportExportModelAdmin):
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    resource_class = EquipmentResource
    list_display = (
    'name', 'model', 'serial_number', 'equipment_type', 'department', 'status', 'next_maintenance_status')
    list_filter = ('status', 'equipment_type', 'department')
    search_fields = ('name', 'model', 'serial_number', 'manufacturer')

    def next_maintenance_status(self, obj):
        if not obj.next_maintenance_date:
            return format_html('<span style="color: gray;">Не указано</span>')

        from django.utils import timezone
        if obj.next_maintenance_date < timezone.now():
            return format_html('<span style="color: red; font-weight: bold;">Просрочено ({})</span>',
                               obj.next_maintenance_date.strftime('%d.%m.%Y %H:%M'))
        else:
            return format_html('<span style="color: green;">{}</span>',
                               obj.next_maintenance_date.strftime('%d.%m.%Y %H:%M'))

    next_maintenance_status.short_description = 'Следующее ТО'


# Админка для обслуживания оборудования
@admin.register(EquipmentMaintenance)
class EquipmentMaintenanceAdmin(ImportExportActionModelAdmin):
    list_display = ('equipment', 'maintenance_type', 'maintenance_date', 'performed_by', 'result')
    list_filter = ('maintenance_type', 'maintenance_date', 'equipment__equipment_type')
    search_fields = ('equipment__name', 'description', 'performed_by__last_name')
    date_hierarchy = 'maintenance_date'


# Админка для опасностей
@admin.register(Hazard)
class HazardAdmin(ImportExportModelAdmin):
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    resource_class = HazardResource
    list_display = ('name', 'category', 'get_risks_count')
    list_filter = ('category',)
    search_fields = ('name', 'description', 'category')

    def get_risks_count(self, obj):
        return obj.risks.count()

    get_risks_count.short_description = 'Количество рисков'


# Админка для рисков
class RiskMitigationMeasureInline(admin.TabularInline):
    model = RiskMitigationMeasure
    extra = 0
    fields = ('description', 'status', 'responsible_person', 'deadline', 'effectiveness_rating')


@admin.register(Risk)
class RiskAdmin(ImportExportModelAdmin):
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    resource_class = RiskResource
    list_display = (
    'hazard', 'department', 'location', 'level', 'probability', 'severity', 'risk_score', 'evaluation_date')
    list_filter = ('level', 'hazard__category', 'department')
    search_fields = ('hazard__name', 'location', 'description')
    date_hierarchy = 'evaluation_date'
    inlines = [RiskMitigationMeasureInline]

    def risk_score(self, obj):
        score = obj.probability * obj.severity
        color = 'green'
        if score > 6:
            color = 'red'
        elif score > 3:
            color = 'orange'
        return format_html('<span style="color: {}; font-weight: bold;">{}</span>', color, score)

    risk_score.short_description = 'Оценка риска'


# Админка для проверок
class InspectionFindingInline(admin.TabularInline):
    model = InspectionFinding
    extra = 0
    fields = ('description', 'severity', 'location', 'responsible_department', 'deadline', 'status')


@admin.register(Inspection)
class InspectionAdmin(ImportExportModelAdmin):
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    resource_class = InspectionResource
    list_display = ('title', 'inspection_type', 'department', 'start_date', 'end_date', 'status', 'get_findings_count')
    list_filter = ('status', 'inspection_type', 'department')
    search_fields = ('title', 'description', 'lead_inspector__last_name')
    date_hierarchy = 'start_date'
    inlines = [InspectionFindingInline]

    def get_findings_count(self, obj):
        return obj.findings.count()

    get_findings_count.short_description = 'Количество нарушений'


# Админка для происшествий
class IncidentVictimInline(admin.TabularInline):
    model = IncidentVictim
    extra = 0
    fields = ('employee', 'injury_description', 'medical_assistance', 'work_days_lost')


@admin.register(Incident)
class IncidentAdmin(ImportExportModelAdmin):
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    resource_class = IncidentResource
    list_display = (
    'title', 'incident_type', 'location', 'department', 'incident_date', 'severity', 'investigation_status')
    list_filter = ('incident_type', 'severity', 'investigation_status', 'department')
    search_fields = ('title', 'description', 'location')
    date_hierarchy = 'incident_date'
    inlines = [IncidentVictimInline]


# Админка для медицинских осмотров
@admin.register(MedicalExamination)
class MedicalExaminationAdmin(ImportExportModelAdmin):
    import_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    export_formats = [base_formats.CSV, base_formats.XLS, base_formats.XLSX]
    resource_class = MedicalExaminationResource
    list_display = ('employee', 'exam_date', 'exam_type', 'result', 'medical_facility', 'next_exam_date')
    list_filter = ('exam_type', 'exam_date', 'result')
    search_fields = ('employee__user__last_name', 'employee__user__first_name', 'medical_facility')
    date_hierarchy = 'exam_date'


# Админка для специальной оценки условий труда
@admin.register(WorkplaceAssessment)
class WorkplaceAssessmentAdmin(ImportExportActionModelAdmin):
    list_display = ('workplace_name', 'department', 'assessment_date', 'next_assessment_date', 'result', 'hazard_class')
    list_filter = ('hazard_class', 'result', 'department')
    search_fields = ('workplace_name', 'assessor', 'notes')
    date_hierarchy = 'assessment_date'


# Админка для задач по охране труда
@admin.register(SafetyTask)
class SafetyTaskAdmin(ImportExportActionModelAdmin):
    list_display = ('title', 'task_type', 'priority', 'status', 'assigned_to', 'department', 'deadline')
    list_filter = ('status', 'priority', 'task_type', 'department')
    search_fields = ('title', 'description', 'assigned_to__last_name')
    date_hierarchy = 'deadline'


# Админка для уведомлений
@admin.register(Notification)
class NotificationAdmin(ImportExportActionModelAdmin):
    list_display = ('user', 'title', 'notification_type', 'is_read', 'created_at')
    list_filter = ('notification_type', 'is_read', 'created_at')
    search_fields = ('user__username', 'user__last_name', 'title', 'message')
    date_hierarchy = 'created_at'
    actions = ['mark_as_read', 'mark_as_unread']

    def mark_as_read(self, request, queryset):
        queryset.update(is_read=True)

    mark_as_read.short_description = "Отметить как прочитанные"

    def mark_as_unread(self, request, queryset):
        queryset.update(is_read=False)

    mark_as_unread.short_description = "Отметить как непрочитанные"


# Админка для логов пользователей
@admin.register(UserLog)
class UserLogAdmin(ImportExportActionModelAdmin):
    list_display = ('user', 'action', 'ip_address', 'timestamp')
    list_filter = ('action', 'timestamp')
    search_fields = ('user__username', 'user__last_name', 'action', 'ip_address')
    date_hierarchy = 'timestamp'
    readonly_fields = ('user', 'action', 'ip_address', 'user_agent', 'details', 'timestamp')


# Настройка заголовка и названия админки
admin.site.site_header = 'Орион - Система безопасности на рабочем месте'
admin.site.site_title = 'Орион'
admin.site.index_title = 'Панель администратора'

~8) admin_site.py;~

from django.contrib import admin
from django.urls import path
from django.utils.decorators import method_decorator
from django.views.generic import TemplateView
from django.contrib.admin.views.decorators import staff_member_required
from django.db.models import Count, Q
from django.utils import timezone
from datetime import timedelta

from .models import (
    Employee, Risk, Instruction, Document, Equipment, Inspection,
    MedicalExamination, Incident, PPERequest, Department, PPEItem, InstructionType, EquipmentMaintenance, Hazard,
    WorkplaceAssessment, SafetyTask, Notification, UserLog
)


class OrionDashboardView(TemplateView):
    template_name = 'admin/orion_dashboard.html'

    @method_decorator(staff_member_required)
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)

        # Текущая дата и важные временные точки
        now = timezone.now()
        today = now.date()
        month_ago = today - timedelta(days=30)

        # Количество сотрудников
        context['employees_count'] = Employee.objects.count()

        # Риски по уровням
        risk_levels = Risk.objects.values('level').annotate(count=Count('id'))
        risk_levels_dict = {item['level']: item['count'] for item in risk_levels}
        context['risk_critical'] = risk_levels_dict.get('critical', 0)
        context['risk_high'] = risk_levels_dict.get('high', 0)
        context['risk_medium'] = risk_levels_dict.get('medium', 0)
        context['risk_low'] = risk_levels_dict.get('low', 0)

        # Медосмотры
        context['overdue_medical_exams'] = Employee.objects.filter(
            next_medical_exam_date__lt=today
        ).count()

        context['upcoming_medical_exams'] = Employee.objects.filter(
            next_medical_exam_date__gte=today,
            next_medical_exam_date__lte=today + timedelta(days=30)
        ).count()

        # Оборудование, требующее обслуживания
        context['equipment_requiring_maintenance'] = Equipment.objects.filter(
            Q(status='requires_maintenance') |
            Q(next_maintenance_date__lt=now)
        ).count()

        # Статистика инструктажей за последний месяц
        context['instructions_last_month'] = Instruction.objects.filter(
            instruction_date__gte=month_ago
        ).count()

        # Статистика происшествий за последний месяц
        context['incidents_last_month'] = Incident.objects.filter(
            incident_date__gte=month_ago
        ).count()

        # Инструктажи, у которых истек срок действия
        context['overdue_instructions'] = Instruction.objects.filter(
            next_instruction_date__lt=now
        ).count()

        # Проверки
        inspection_statuses = Inspection.objects.values('status').annotate(count=Count('id'))
        inspection_statuses_dict = {item['status']: item['count'] for item in inspection_statuses}
        context['inspections_new'] = inspection_statuses_dict.get('new', 0)
        context['inspections_in_progress'] = inspection_statuses_dict.get('in_progress', 0)
        context['inspections_completed'] = inspection_statuses_dict.get('completed', 0)

        # Заявки на СИЗ
        ppe_request_statuses = PPERequest.objects.values('status').annotate(count=Count('id'))
        ppe_request_statuses_dict = {item['status']: item['count'] for item in ppe_request_statuses}
        context['ppe_requests_new'] = ppe_request_statuses_dict.get('new', 0)
        context['ppe_requests_in_progress'] = ppe_request_statuses_dict.get('in_progress', 0)
        context['ppe_requests_completed'] = ppe_request_statuses_dict.get('completed', 0)

        # Нарушения
        findings_count = 0
        resolved_findings_count = 0

        for inspection in Inspection.objects.all():
            findings = inspection.findings.all()
            findings_count += findings.count()
            resolved_findings_count += findings.filter(status='completed').count()

        if findings_count > 0:
            context['compliance_percentage'] = int((resolved_findings_count / findings_count) * 100)
        else:
            context['compliance_percentage'] = 100

        # Последний инцидент
        last_incident = Incident.objects.order_by('-incident_date').first()
        if last_incident:
            context['incident_free_days'] = (today - last_incident.incident_date.date()).days
        else:
            context['incident_free_days'] = 365

        # Недавние документы
        context['recent_documents'] = Document.objects.order_by('-updated_at')[:5]

        # Ближайшие инструктажи
        context['upcoming_instructions'] = Instruction.objects.filter(
            next_instruction_date__gte=today
        ).order_by('next_instruction_date')[:5]

        return context


class OrionAdminSite(admin.AdminSite):
    site_header = 'Орион - Система безопасности на рабочем месте'
    site_title = 'Орион'
    index_title = 'Панель администратора'

    def get_urls(self):
        urls = super().get_urls()
        custom_urls = [
            path('dashboard/', self.admin_view(OrionDashboardView.as_view()), name='orion_dashboard'),
        ]
        return custom_urls + urls


# Инициализация собственного AdminSite
orion_admin_site = OrionAdminSite(name='orion_admin')

# Импортируем все классы админки из admin.py
from .admin import (
    CustomUserAdmin, DepartmentAdmin, EmployeeAdmin, PPEItemAdmin,
    PPERequestAdmin, DocumentAdmin, InstructionTypeAdmin, InstructionAdmin,
    EquipmentAdmin, EquipmentMaintenanceAdmin, HazardAdmin, RiskAdmin,
    InspectionAdmin, IncidentAdmin, MedicalExaminationAdmin,
    WorkplaceAssessmentAdmin, SafetyTaskAdmin, NotificationAdmin, UserLogAdmin
)

# Импортируем модель User
from django.contrib.auth.models import User

# Регистрируем модели в нашей кастомной админке
orion_admin_site.register(User, CustomUserAdmin)
orion_admin_site.register(Department, DepartmentAdmin)
orion_admin_site.register(Employee, EmployeeAdmin)
orion_admin_site.register(PPEItem, PPEItemAdmin)
orion_admin_site.register(PPERequest, PPERequestAdmin)
orion_admin_site.register(Document, DocumentAdmin)
orion_admin_site.register(InstructionType, InstructionTypeAdmin)
orion_admin_site.register(Instruction, InstructionAdmin)
orion_admin_site.register(Equipment, EquipmentAdmin)
orion_admin_site.register(EquipmentMaintenance, EquipmentMaintenanceAdmin)
orion_admin_site.register(Hazard, HazardAdmin)
orion_admin_site.register(Risk, RiskAdmin)
orion_admin_site.register(Inspection, InspectionAdmin)
orion_admin_site.register(Incident, IncidentAdmin)
orion_admin_site.register(MedicalExamination, MedicalExaminationAdmin)
orion_admin_site.register(WorkplaceAssessment, WorkplaceAssessmentAdmin)
orion_admin_site.register(SafetyTask, SafetyTaskAdmin)
orion_admin_site.register(Notification, NotificationAdmin)
orion_admin_site.register(UserLog, UserLogAdmin)

~9) apps.py;~

from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

    def ready(self):
        import core.signals


~10) cron_jobs.py;~

# Хотя сигналы будут работать при любом сохранении сотрудника или медосмотра,
# стоит также добавить периодическую задачу, которая будет проверять медосмотры регулярно.
# Для этого можно использовать Django Celery или django-crontab.

# Пример настройки django-crontab:
# 1. Установите пакет: pip install django-crontab
# 2. Добавьте 'django_crontab' в INSTALLED_APPS в settings.py
# 3. Создайте файл с задачами cron_jobs.py:

# core/cron_jobs.py
from django.utils import timezone
from datetime import timedelta
from .models import Employee, Notification
from .signals import notify_medical_workers


def check_medical_exams():
    """
    Периодическая проверка состояния медицинских осмотров всех сотрудников.
    Запускается автоматически по расписанию cron.
    """
    current_date = timezone.now().date()
    warning_date = current_date + timedelta(days=5)

    # Сотрудники с просроченными медосмотрами
    overdue_employees = Employee.objects.filter(
        next_medical_exam_date__lt=current_date
    )

    # Сотрудники с приближающимися медосмотрами
    upcoming_employees = Employee.objects.filter(
        next_medical_exam_date__gte=current_date,
        next_medical_exam_date__lte=warning_date
    )

    # Счетчики для статистики
    overdue_count = 0
    upcoming_count = 0

    # Обрабатываем просроченные медосмотры
    for employee in overdue_employees:
        # Проверяем, не было ли уже уведомления за последние 7 дней
        recent_notification = Notification.objects.filter(
            user=employee.user,
            notification_type='medical',
            created_at__gte=timezone.now() - timedelta(days=7)
        ).exists()

        if not recent_notification:
            # Создаем уведомление для сотрудника
            Notification.objects.create(
                user=employee.user,
                title='Медицинский осмотр просрочен',
                message='Ваш медицинский осмотр просрочен. Пожалуйста, обратитесь в медицинский отдел для согласования даты.',
                notification_type='medical',
                related_entity_type='employee',
                related_entity_id=employee.id,
                is_read=False
            )
            overdue_count += 1

    # Обрабатываем приближающиеся медосмотры
    for employee in upcoming_employees:
        # Проверяем, не было ли уже уведомления за последние 3 дня
        recent_notification = Notification.objects.filter(
            user=employee.user,
            notification_type='medical_warning',
            created_at__gte=timezone.now() - timedelta(days=3)
        ).exists()

        if not recent_notification:
            days_left = (employee.next_medical_exam_date - current_date).days

            # Создаем уведомление для сотрудника
            Notification.objects.create(
                user=employee.user,
                title='Приближается медицинский осмотр',
                message=f'Ваш медицинский осмотр назначен через {days_left} дней. Пожалуйста, не забудьте посетить медицинский отдел.',
                notification_type='medical_warning',
                related_entity_type='employee',
                related_entity_id=employee.id,
                is_read=False
            )
            upcoming_count += 1

    if overdue_count > 0:
        notify_medical_workers(
            'Сводка просроченных медосмотров',
            f'В системе {overdue_count} сотрудников с просроченными медосмотрами. Требуется ваше внимание.',
            'medical_overdue_summary'
        )

    if upcoming_count > 0:
        notify_medical_workers(
            'Сводка приближающихся медосмотров',
            f'В системе {upcoming_count} сотрудников с медосмотрами в ближайшие 5 дней.',
            'medical_upcoming_summary'
        )

    return f"Processed: {overdue_count} overdue and {upcoming_count} upcoming exams."
# python manage.py crontab add

~11) customlogger.py;~

import logging
import os
import psycopg2
import threading
import time
from influxdb_client import InfluxDBClient, Point
from influxdb_client.client.write_api import SYNCHRONOUS
from prometheus_client import Counter, Gauge, REGISTRY

class ResettableCounter:
    def __init__(self, name, documentation):
        self._counter = Counter(name, documentation)
        self._value = 0
        self.name = name

    def inc(self, amount=1):
        self._value += amount
        self._counter.inc(amount)

    def reset(self):
        try:
            if self.name in REGISTRY._names_to_collectors:
                REGISTRY.unregister(self._counter)
        except:
            pass

        self._value = 0
        self._counter = Counter(self.name, self._counter._documentation)


log_counters = {
    'django_log_info_total': Counter('django_log_info_total', 'Total number of info log messages'),
    'django_log_warning_total': ResettableCounter('django_log_warning_total', 'Total number of warning log messages'),
    'django_log_error_total': Counter('django_log_error_total', 'Total number of error log messages'),
}

database_size_gauge = Gauge('database_size_bytes', 'Size of database in bytes')

token = "UeVtpMYBGfA3fENfwoTCfnWJtIEOBA6Mqk9r0F6guxiD1hoD6SMwRvGXx8Z7prultF5fdIemLFHE7qySaqz2FQ=="
org = "mpt"
url = "http://localhost:8086"
bucket = "metrics"

write_client = InfluxDBClient(url=url, token=token, org=org)
write_api = write_client.write_api(write_options=SYNCHRONOUS)


class WarningMetricResetter(threading.Thread):
    def __init__(self, reset_interval=300):
        super().__init__()
        self.reset_interval = reset_interval
        self.daemon = True
        self.last_warning_time = 0
        self.running = True

    def run(self):
        while self.running:
            current_time = time.time()
            if current_time - self.last_warning_time > self.reset_interval and self.last_warning_time > 0:
                log_counters['django_log_warning_total'].reset()
                print("Warning counter has been reset automatically")
            time.sleep(10)

    def update_last_warning(self):
        self.last_warning_time = time.time()


warning_resetter = WarningMetricResetter()
warning_resetter.start()


class PrometheusLogHandler(logging.Handler):
    def emit(self, record):
        if record.levelno == logging.INFO:
            log_counters['django_log_info_total'].inc()
            point = Point("django_log_info_total_influxdb") \
                .tag("level", "INFO") \
                .tag("app", "django") \
                .field("info_influxdb", 1)
            write_api.write(bucket=bucket, record=point)

        elif record.levelno == logging.WARNING:
            log_counters['django_log_warning_total'].inc()
            warning_resetter.update_last_warning()

            point = Point("django_log_warning_total_influxdb") \
                .tag("level", "WARNING") \
                .tag("app", "django") \
                .field("warning_influxdb", 1)
            write_api.write(bucket=bucket, record=point)

            if log_counters['django_log_warning_total']._value >= 5:
                alert_point = Point("django_log_warning_threshold") \
                    .tag("level", "WARNING") \
                    .tag("app", "django") \
                    .field("value", log_counters['django_log_warning_total']._value) \
                    .field("threshold_exceeded", True)
                write_api.write(bucket=bucket, record=alert_point)

        elif record.levelno == logging.ERROR:
            log_counters['django_log_error_total'].inc()
            point = Point("django_log_error_total_influxdb") \
                .tag("level", "ERROR") \
                .tag("app", "django") \
                .field("error_influxdb", 1)
            write_api.write(bucket=bucket, record=point)

        try:
            conn = psycopg2.connect(
                dbname="workplacesafety",
                user="postgres",
                password="143952",
                host="localhost",
                port="5432"
            )
            cur = conn.cursor()
            cur.execute("SELECT pg_database_size('workplacesafety')")
            size = cur.fetchone()[0]
            database_size_gauge.set(size)

            point = Point("database_size_bytes") \
                .tag("database", "workplacesafety") \
                .field("db_size", size)
            write_api.write(bucket=bucket, record=point)

            cur.close()
            conn.close()
        except Exception as e:
            print(f"Error getting database size: {e}")

    def reset_warning_counter(self):
        log_counters['django_log_warning_total'].reset()
        reset_point = Point("django_log_warning_reset") \
            .tag("app", "django") \
            .field("reset", True)
        write_api.write(bucket=bucket, record=reset_point)
        print("Warning counter has been manually reset")

~12) decorators.py;~

from django.shortcuts import redirect
from django.contrib import messages
from functools import wraps


def role_required(allowed_roles):
    """
    Декоратор, который проверяет роль пользователя и разрешает доступ только определенным ролям.

    Пример использования:
    @role_required(['admin', 'safety_specialist'])
    def some_view(request):
        # обработка представления
    """

    def decorator(view_func):
        @wraps(view_func)
        def _wrapped_view(request, *args, **kwargs):
            if not request.user.is_authenticated:
                return redirect('login')

            try:
                user_role = request.user.employee.role
            except:
                user_role = 'employee'  # По умолчанию

            if user_role not in allowed_roles:
                messages.error(request, 'У вас нет доступа к данному разделу системы.')
                return redirect('dashboard')

            return view_func(request, *args, **kwargs)

        return _wrapped_view

    return decorator


def view_only_permission(original_view):
    """
    Декоратор, который разрешает только просмотр (GET-запросы) и запрещает изменения.
    Используется для представлений, где некоторые роли могут только просматривать данные.
    """

    @wraps(original_view)
    def _wrapped_view(request, *args, **kwargs):
        if request.method != 'GET':
            messages.error(request, 'У вас есть доступ только для просмотра данного раздела.')
            return redirect('dashboard')
        return original_view(request, *args, **kwargs)

    return _wrapped_view

~13) forms.py;~

from django import forms
from django.contrib.auth.models import User
from django.contrib.auth.forms import UserCreationForm
from .models import (
    PPERequest, PPEIssuance, Instruction, Document, Equipment, EquipmentMaintenance,
    Risk, RiskMitigationMeasure, Inspection, InspectionFinding, Incident, SafetyTask,
    Employee, Department, InstructionType, Hazard, PPEItem, MedicalExamination, TestQuestion, TestAnswer,
    InstructionTest, InstructionMaterial
)


# Форма профиля пользователя
class ProfileForm(forms.ModelForm):
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'email']
        widgets = {
            'first_name': forms.TextInput(attrs={'class': 'form-control'}),
            'last_name': forms.TextInput(attrs={'class': 'form-control'}),
            'email': forms.EmailInput(attrs={'class': 'form-control'}),
        }


# Форма регистрации пользователя с дополнительными полями
class UserRegisterForm(UserCreationForm):
    email = forms.EmailField(required=True, widget=forms.EmailInput(attrs={'class': 'form-control'}))
    first_name = forms.CharField(required=True, widget=forms.TextInput(attrs={'class': 'form-control'}))
    last_name = forms.CharField(required=True, widget=forms.TextInput(attrs={'class': 'form-control'}))

    class Meta:
        model = User
        fields = ['username', 'email', 'first_name', 'last_name', 'password1', 'password2']
        widgets = {
            'username': forms.TextInput(attrs={'class': 'form-control'}),
        }

    def __init__(self, *args, **kwargs):
        super(UserRegisterForm, self).__init__(*args, **kwargs)
        self.fields['password1'].widget = forms.PasswordInput(attrs={'class': 'form-control'})
        self.fields['password2'].widget = forms.PasswordInput(attrs={'class': 'form-control'})


# Форма сотрудника
class EmployeeForm(forms.ModelForm):
    class Meta:
        model = Employee
        fields = [
            'department', 'position', 'hire_date', 'medical_exam_date',
            'next_medical_exam_date', 'personal_id_number', 'emergency_contact', 'notes'
        ]
        widgets = {
            'department': forms.Select(attrs={'class': 'form-control'}),
            'position': forms.TextInput(attrs={'class': 'form-control'}),
            'hire_date': forms.DateInput(attrs={'class': 'form-control', 'type': 'date'}),
            'medical_exam_date': forms.DateInput(attrs={'class': 'form-control', 'type': 'date'}),
            'next_medical_exam_date': forms.DateInput(attrs={'class': 'form-control', 'type': 'date'}),
            'personal_id_number': forms.TextInput(attrs={'class': 'form-control'}),
            'emergency_contact': forms.TextInput(attrs={'class': 'form-control'}),
            'notes': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


# Форма заявки на СИЗ
class PPERequestForm(forms.ModelForm):
    class Meta:
        model = PPERequest
        fields = ['employee', 'ppe_item', 'quantity', 'notes']
        widgets = {
            'employee': forms.Select(attrs={'class': 'form-control'}),
            'ppe_item': forms.Select(attrs={'class': 'form-control'}),
            'quantity': forms.NumberInput(attrs={'class': 'form-control', 'min': 1}),
            'notes': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


# Форма выдачи СИЗ
class PPEIssuanceForm(forms.ModelForm):
    class Meta:
        model = PPEIssuance
        fields = [
            'employee', 'ppe_item', 'quantity', 'expected_return_date',
            'condition_on_issue', 'notes'
        ]
        widgets = {
            'employee': forms.Select(attrs={'class': 'form-control'}),
            'ppe_item': forms.Select(attrs={'class': 'form-control'}),
            'quantity': forms.NumberInput(attrs={'class': 'form-control', 'min': 1}),
            'expected_return_date': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'condition_on_issue': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'notes': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


# Форма проведения инструктажа
class InstructionForm(forms.ModelForm):
    class Meta:
        model = Instruction
        fields = [
            'instruction_type', 'department', 'instruction_date', 'next_instruction_date',
            'location', 'duration', 'notes'
        ]
        widgets = {
            'instruction_type': forms.Select(attrs={'class': 'form-control'}),
            'department': forms.Select(attrs={'class': 'form-control'}),
            'instruction_date': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'next_instruction_date': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'location': forms.TextInput(attrs={'class': 'form-control'}),
            'duration': forms.NumberInput(attrs={'class': 'form-control', 'min': 1}),
            'notes': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


# Форма документа
class DocumentForm(forms.ModelForm):
    class Meta:
        model = Document
        fields = [
            'title', 'document_type', 'file', 'description', 'publish_date',
            'effective_date', 'expiry_date', 'version', 'author', 'is_active'
        ]
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control'}),
            'document_type': forms.TextInput(attrs={'class': 'form-control'}),
            'file': forms.FileInput(attrs={'class': 'form-control'}),
            'description': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'publish_date': forms.DateInput(attrs={'class': 'form-control', 'type': 'date'}),
            'effective_date': forms.DateInput(attrs={'class': 'form-control', 'type': 'date'}),
            'expiry_date': forms.DateInput(attrs={'class': 'form-control', 'type': 'date'}),
            'version': forms.TextInput(attrs={'class': 'form-control'}),
            'author': forms.TextInput(attrs={'class': 'form-control'}),
            'is_active': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
        }


# Форма оборудования
class EquipmentForm(forms.ModelForm):
    class Meta:
        model = Equipment
        fields = [
            'name', 'equipment_type', 'model', 'serial_number', 'manufacturer',
            'purchase_date', 'warranty_expiry_date', 'department', 'location',
            'status', 'responsible_person', 'notes'
        ]
        widgets = {
            'name': forms.TextInput(attrs={'class': 'form-control'}),
            'equipment_type': forms.TextInput(attrs={'class': 'form-control'}),
            'model': forms.TextInput(attrs={'class': 'form-control'}),
            'serial_number': forms.TextInput(attrs={'class': 'form-control'}),
            'manufacturer': forms.TextInput(attrs={'class': 'form-control'}),
            'purchase_date': forms.DateInput(attrs={'class': 'form-control', 'type': 'date'}),
            'warranty_expiry_date': forms.DateInput(attrs={'class': 'form-control', 'type': 'date'}),
            'department': forms.Select(attrs={'class': 'form-control'}),
            'location': forms.TextInput(attrs={'class': 'form-control'}),
            'status': forms.Select(attrs={'class': 'form-control'}),
            'responsible_person': forms.Select(attrs={'class': 'form-control'}),
            'notes': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


# Форма обслуживания оборудования
class EquipmentMaintenanceForm(forms.ModelForm):
    class Meta:
        model = EquipmentMaintenance
        fields = [
            'maintenance_type', 'maintenance_date', 'description', 'result',
            'next_maintenance_date', 'documents_path', 'notes'
        ]
        widgets = {
            'maintenance_type': forms.TextInput(attrs={'class': 'form-control'}),
            'maintenance_date': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'description': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'result': forms.TextInput(attrs={'class': 'form-control'}),
            'next_maintenance_date': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'documents_path': forms.TextInput(attrs={'class': 'form-control'}),
            'notes': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


# Форма риска
class RiskForm(forms.ModelForm):
    class Meta:
        model = Risk
        fields = [
            'hazard', 'department', 'location', 'level', 'probability', 'severity', 'description'
        ]
        widgets = {
            'hazard': forms.Select(attrs={'class': 'form-control'}),
            'department': forms.Select(attrs={'class': 'form-control'}),
            'location': forms.TextInput(attrs={'class': 'form-control'}),
            'level': forms.Select(attrs={'class': 'form-control'}),
            'probability': forms.NumberInput(attrs={'class': 'form-control', 'min': 0, 'max': 1, 'step': 0.1}),
            'severity': forms.NumberInput(attrs={'class': 'form-control', 'min': 1, 'max': 10}),
            'description': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


# Форма мероприятия по снижению риска
class RiskMitigationMeasureForm(forms.ModelForm):
    class Meta:
        model = RiskMitigationMeasure
        fields = [
            'description', 'status', 'responsible_person', 'deadline', 'notes'
        ]
        widgets = {
            'description': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'status': forms.Select(attrs={'class': 'form-control'}),
            'responsible_person': forms.Select(attrs={'class': 'form-control'}),
            'deadline': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'notes': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


# Форма проверки
class InspectionForm(forms.ModelForm):
    class Meta:
        model = Inspection
        fields = [
            'title', 'inspection_type', 'department', 'start_date', 'end_date',
            'status', 'description'
        ]
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control'}),
            'inspection_type': forms.TextInput(attrs={'class': 'form-control'}),
            'department': forms.Select(attrs={'class': 'form-control'}),
            'start_date': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'end_date': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'status': forms.Select(attrs={'class': 'form-control'}),
            'description': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


# Форма выявленного нарушения
class InspectionFindingForm(forms.ModelForm):
    class Meta:
        model = InspectionFinding
        fields = [
            'description', 'severity', 'location', 'responsible_department',
            'deadline', 'status', 'resolution'
        ]
        widgets = {
            'description': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'severity': forms.TextInput(attrs={'class': 'form-control'}),
            'location': forms.TextInput(attrs={'class': 'form-control'}),
            'responsible_department': forms.Select(attrs={'class': 'form-control'}),
            'deadline': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'status': forms.Select(attrs={'class': 'form-control'}),
            'resolution': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


# Форма происшествия
class IncidentForm(forms.ModelForm):
    class Meta:
        model = Incident
        fields = [
            'title', 'incident_type', 'location', 'department', 'incident_date',
            'description', 'severity', 'immediate_actions'
        ]
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control'}),
            'incident_type': forms.TextInput(attrs={'class': 'form-control'}),
            'location': forms.TextInput(attrs={'class': 'form-control'}),
            'department': forms.Select(attrs={'class': 'form-control'}),
            'incident_date': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'description': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'severity': forms.TextInput(attrs={'class': 'form-control'}),
            'immediate_actions': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }

class MedicalExaminationForm(forms.ModelForm):
    class Meta:
        model = MedicalExamination
        fields = [
            'employee', 'exam_date', 'next_exam_date', 'exam_type',
            'medical_facility', 'doctor', 'result', 'recommendations',
            'restrictions', 'document', 'notes'
        ]
        widgets = {
            'employee': forms.Select(attrs={'class': 'form-control'}),
            'exam_date': forms.DateInput(attrs={'class': 'form-control', 'type': 'date'}),
            'next_exam_date': forms.DateInput(attrs={'class': 'form-control', 'type': 'date'}),
            'exam_type': forms.TextInput(attrs={'class': 'form-control'}),
            'medical_facility': forms.TextInput(attrs={'class': 'form-control'}),
            'doctor': forms.TextInput(attrs={'class': 'form-control'}),
            'result': forms.TextInput(attrs={'class': 'form-control'}),
            'recommendations': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'restrictions': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'document': forms.FileInput(attrs={'class': 'form-control'}),
            'notes': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }


class InstructionMaterialForm(forms.ModelForm):
    class Meta:
        model = InstructionMaterial
        fields = ['title', 'content', 'file', 'order']
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control'}),
            'content': forms.Textarea(attrs={'class': 'form-control', 'rows': 5}),
            'file': forms.FileInput(attrs={'class': 'form-control'}),
            'order': forms.NumberInput(attrs={'class': 'form-control', 'min': 0}),
        }


class InstructionTestForm(forms.ModelForm):
    class Meta:
        model = InstructionTest
        fields = ['title', 'description', 'passing_score', 'time_limit', 'is_active']
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control'}),
            'description': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'passing_score': forms.NumberInput(attrs={'class': 'form-control', 'min': 0, 'max': 100}),
            'time_limit': forms.NumberInput(attrs={'class': 'form-control', 'min': 0}),
            'is_active': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
        }


class TestQuestionForm(forms.ModelForm):
    class Meta:
        model = TestQuestion
        fields = ['question_text', 'order']
        widgets = {
            'question_text': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'order': forms.NumberInput(attrs={'class': 'form-control', 'min': 0}),
        }


class TestAnswerForm(forms.ModelForm):
    class Meta:
        model = TestAnswer
        fields = ['answer_text', 'is_correct', 'order']
        widgets = {
            'answer_text': forms.TextInput(attrs={'class': 'form-control'}),
            'is_correct': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
            'order': forms.NumberInput(attrs={'class': 'form-control', 'min': 0}),
        }


# Form for inline formsets
TestAnswerFormSet = forms.inlineformset_factory(
    TestQuestion,
    TestAnswer,
    form=TestAnswerForm,
    extra=4,
    max_num=10,
    can_delete=True
)


# Form for taking a test
class TestSubmissionForm(forms.Form):
    def __init__(self, test, *args, **kwargs):
        super(TestSubmissionForm, self).__init__(*args, **kwargs)

        # Add a field for each question
        for question in test.questions.all().order_by('order'):
            choices = [(answer.id, answer.answer_text) for answer in question.answers.all().order_by('order')]
            self.fields[f'question_{question.id}'] = forms.ChoiceField(
                label=question.question_text,
                choices=choices,
                widget=forms.RadioSelect(attrs={'class': 'form-check-input'}),
                required=True
            )

# Форма задачи по охране труда
class SafetyTaskForm(forms.ModelForm):
    class Meta:
        model = SafetyTask
        fields = [
            'title', 'description', 'task_type', 'priority', 'status',
            'assigned_to', 'department', 'start_date', 'deadline', 'notes'
        ]
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control'}),
            'description': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'task_type': forms.TextInput(attrs={'class': 'form-control'}),
            'priority': forms.Select(attrs={'class': 'form-control'}, choices=[
                ('low', 'Низкий'),
                ('medium', 'Средний'),
                ('high', 'Высокий'),
                ('critical', 'Критический')
            ]),
            'status': forms.Select(attrs={'class': 'form-control'}),
            'assigned_to': forms.Select(attrs={'class': 'form-control'}),
            'department': forms.Select(attrs={'class': 'form-control'}),
            'start_date': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'deadline': forms.DateTimeInput(attrs={'class': 'form-control', 'type': 'datetime-local'}),
            'notes': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }

~14) middleware.py;~

# middleware.py
from django.shortcuts import redirect
from django.urls import reverse
from django.contrib import messages


class RoleBasedAccessMiddleware:

    def __init__(self, get_response):
        self.get_response = get_response

        # Карта доступа к URL-паттернам для каждой роли
        self.access_map = {
            'admin': ['*'],  # У администратора доступ ко всем страницам
            'safety_specialist': [
                'dashboard', 'search', 'profile', 'notification', 'api_',
                'ppe_', 'instruction_', 'document_', 'risk_', 'inspection_', 'report_', 'equipment_',
                'employee_list', 'employee_detail'  # Специалист ОТ может только просматривать сотрудников
            ],
            'department_head': [
                'dashboard', 'search', 'profile', 'notification', 'api_',
                'ppe_', 'instruction_', 'document_', 'employee_',
                'risk_list', 'risk_detail',  # Руководитель может только просматривать риски
                'inspection_list', 'inspection_detail',  # Руководитель может только просматривать проверки
                'equipment_list', 'equipment_detail'  # Руководитель может только просматривать оборудование
            ],
            'employee': [
                'dashboard', 'search', 'profile', 'notification', 'api_',
                'document_list', 'document_detail',  # Сотрудник может только просматривать документы
                'ppe_create', 'ppe_detail'  # Сотрудник может создавать заявки и смотреть детали своих заявок
            ],
            'medical_worker': [
                'dashboard', 'search', 'profile', 'notification', 'api_',
                'document_list', 'document_detail',  # Медик может только просматривать документы
                'employee_list', 'employee_detail',  # Медик может просматривать сотрудников
                'medical_'  # Медик имеет полный доступ к медосмотрам
            ],
            'technician': [
                'dashboard', 'search', 'profile', 'notification', 'api_',
                'equipment_', 'equipment_maintenance'  # Техник имеет полный доступ к оборудованию
            ],
        }

        # URL-адреса, доступные всем (в том числе неавторизованным пользователям)
        self.public_paths = [
            'login',
            'logout',
            'password_reset',
            'password_reset_done',
            'password_reset_confirm',
            'password_reset_complete',
        ]

        # Пути, исключенные из проверки доступа (для аутентифицированных пользователей)
        self.auth_paths = [
            'dashboard',  # Дашборд доступен всем авторизованным
            'profile',
            'search',
            'notifications',
            'notification_mark_read',
            'notifications_mark_all_read',
            'api_stats',
            'api_notifications',
        ]

    def __call__(self, request):
        if not request.user.is_authenticated:
            # Пропускаем неаутентифицированных пользователей (будет обработано auth middleware)
            return self.get_response(request)

        # Если путь не установлен, пропускаем проверку
        if not hasattr(request, 'resolver_match') or not request.resolver_match:
            return self.get_response(request)

        path_name = request.resolver_match.url_name if request.resolver_match else ''
        app_name = request.resolver_match.app_name if request.resolver_match else ''

        full_path = f"{app_name}:{path_name}" if app_name else path_name

        # Если путь публичный или входит в исключения для аутентифицированных, пропускаем проверку
        if path_name in self.public_paths or path_name in self.auth_paths:
            return self.get_response(request)

        # Если путь связан с административной панелью Django, пропускаем для админа или блокируем для других
        if full_path.startswith('admin:') or path_name.startswith('admin:'):
            try:
                if request.user.employee.role == 'admin':
                    return self.get_response(request)
                else:
                    messages.error(request, 'У вас нет доступа к административной панели.')
                    return redirect('dashboard')
            except:
                messages.error(request, 'У вас нет доступа к административной панели.')
                return redirect('dashboard')

        # Получаем роль пользователя
        try:
            employee = request.user.employee
            user_role = employee.role
        except Exception:
            user_role = 'employee'  # По умолчанию

        # Проверяем доступ на основе роли
        has_access = self.check_access(user_role, full_path)

        if not has_access:
            messages.error(request, 'У вас нет доступа к данной функции.')

            # Перенаправляем на дашборд, т.к. пользователь уже авторизован
            return redirect('dashboard')

        # Проверка специальных ограничений для определенных ролей
        if user_role == 'department_head':
            # Для руководителя департамента ограничиваем действия с рисками, проверками и оборудованием - только просмотр
            if (path_name.startswith('risk_') and path_name not in ['risk_list', 'risk_detail']) or \
                    (path_name.startswith('inspection_') and path_name not in ['inspection_list',
                                                                               'inspection_detail']) or \
                    (path_name.startswith('equipment_') and path_name not in ['equipment_list', 'equipment_detail']):
                messages.error(request, 'У вас есть доступ только для просмотра данного раздела.')
                # Перенаправляем на страницу списка соответствующего раздела
                if path_name.startswith('risk_'):
                    return redirect('risk_list')
                elif path_name.startswith('inspection_'):
                    return redirect('inspection_list')
                elif path_name.startswith('equipment_'):
                    return redirect('equipment_list')

        if user_role == 'safety_specialist':
            # Для специалиста ОТ ограничиваем действия с сотрудниками - только просмотр
            if path_name.startswith('employee_') and path_name not in ['employee_list', 'employee_detail']:
                messages.error(request, 'У вас есть доступ только для просмотра данного раздела.')
                return redirect('employee_list')

        if user_role == 'employee':
            # Для обычного сотрудника ограничиваем действия с документами - только просмотр
            if path_name.startswith('document_') and path_name not in ['document_list', 'document_detail']:
                messages.error(request, 'У вас есть доступ только для просмотра документов.')
                return redirect('document_list')

        if user_role == 'medical_worker':
            # Для медработника ограничиваем действия с документами и сотрудниками - только просмотр
            if path_name.startswith('document_') and path_name not in ['document_list', 'document_detail']:
                messages.error(request, 'У вас есть доступ только для просмотра документов.')
                return redirect('document_list')
            elif path_name.startswith('employee_') and path_name not in ['employee_list', 'employee_detail']:
                messages.error(request, 'У вас есть доступ только для просмотра данных сотрудников.')
                return redirect('employee_list')

        response = self.get_response(request)
        return response

    def check_access(self, role, path):
        """Проверка доступа пользователя к URL на основе роли"""
        if role not in self.access_map:
            return False

        allowed_paths = self.access_map[role]

        # Для администратора разрешен доступ ко всему
        if '*' in allowed_paths:
            return True

        # Проверяем, есть ли у роли доступ к данному пути
        for allowed_path in allowed_paths:
            if path == allowed_path or path.startswith(allowed_path):
                return True

        return False

~15) models.py;~

from datetime import time

from django.db.models import JSONField
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone

# Перечисления для статусов
TASK_STATUS_CHOICES = [
    ('new', 'Новая'),
    ('in_progress', 'В обработке'),
    ('completed', 'Выполнено'),
    ('canceled', 'Отменено'),
]

RISK_LEVEL_CHOICES = [
    ('low', 'Низкий'),
    ('medium', 'Средний'),
    ('high', 'Высокий'),
    ('critical', 'Критический'),
]

EQUIPMENT_STATUS_CHOICES = [
    ('operational', 'Исправно'),
    ('requires_maintenance', 'Требуется обслуживание'),
    ('under_maintenance', 'На обслуживании'),
    ('decommissioned', 'Выведено из эксплуатации'),
]


# Подразделения
class Department(models.Model):
    name = models.CharField(max_length=255, verbose_name='Название')
    description = models.TextField(blank=True, null=True, verbose_name='Описание')
    parent = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, related_name='children',
                               verbose_name='Родительское подразделение')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Подразделение'
        verbose_name_plural = 'Подразделения'
        ordering = ['name']

    def __str__(self):
        return self.name


class Employee(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='employee', verbose_name='Пользователь')
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True,
                                   related_name='employees', verbose_name='Подразделение')
    position = models.CharField(max_length=255, verbose_name='Должность')
    role = models.CharField(max_length=50, choices=[
        ('admin', 'Администратор'),
        ('safety_specialist', 'Специалист по охране труда'),
        ('department_head', 'Руководитель подразделения'),
        ('employee', 'Сотрудник'),
        ('medical_worker', 'Медицинский работник'),
        ('technician', 'Техник')
    ], default='employee', verbose_name='Роль')
    hire_date = models.DateField(verbose_name='Дата приема на работу')
    medical_exam_date = models.DateField(null=True, blank=True, verbose_name='Дата последнего медосмотра')
    next_medical_exam_date = models.DateField(null=True, blank=True, verbose_name='Дата следующего медосмотра')
    personal_id_number = models.CharField(max_length=50, unique=True, null=True, blank=True,
                                          verbose_name='Табельный номер')
    emergency_contact = models.CharField(max_length=255, null=True, blank=True, verbose_name='Экстренный контакт')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')


    class Meta:
        verbose_name = 'Сотрудник'
        verbose_name_plural = 'Сотрудники'
        ordering = ['user__last_name', 'user__first_name']

    def __str__(self):
        return f"{self.user.last_name} {self.user.first_name}"

    @property
    def full_name(self):
        return f"{self.user.last_name} {self.user.first_name}"


class PPEItem(models.Model):
    name = models.CharField(max_length=255, verbose_name='Наименование')
    description = models.TextField(blank=True, null=True, verbose_name='Описание')
    category = models.CharField(max_length=100, verbose_name='Категория')
    standard_issue_period = models.IntegerField(null=True, blank=True, verbose_name='Стандартный период выдачи (дни)')
    certification_number = models.CharField(max_length=100, null=True, blank=True, verbose_name='Номер сертификата')
    manufacturer = models.CharField(max_length=255, null=True, blank=True, verbose_name='Производитель')
    supplier = models.CharField(max_length=255, null=True, blank=True, verbose_name='Поставщик')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'СИЗ'
        verbose_name_plural = 'СИЗ'
        ordering = ['name']

    def __str__(self):
        return self.name


class PPERequest(models.Model):
    employee = models.ForeignKey(Employee, on_delete=models.CASCADE, related_name='ppe_requests',
                                 verbose_name='Сотрудник')
    ppe_item = models.ForeignKey(PPEItem, on_delete=models.CASCADE, related_name='requests', verbose_name='СИЗ')
    quantity = models.IntegerField(default=1, verbose_name='Количество')
    request_date = models.DateTimeField(default=timezone.now, verbose_name='Дата заявки')
    status = models.CharField(max_length=20, choices=TASK_STATUS_CHOICES, default='new', verbose_name='Статус')
    processed_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True,
                                     related_name='processed_ppe_requests', verbose_name='Обработал')
    processed_date = models.DateTimeField(null=True, blank=True, verbose_name='Дата обработки')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Заявка на СИЗ'
        verbose_name_plural = 'Заявки на СИЗ'
        ordering = ['-request_date']

    def __str__(self):
        return f"Заявка #{self.pk} от {self.employee} на {self.ppe_item.name}"


class PPEIssuance(models.Model):
    request = models.ForeignKey(PPERequest, on_delete=models.SET_NULL, null=True, blank=True, related_name='issuances',
                                verbose_name='Заявка')
    employee = models.ForeignKey(Employee, on_delete=models.CASCADE, related_name='ppe_issuances',
                                 verbose_name='Сотрудник')
    ppe_item = models.ForeignKey(PPEItem, on_delete=models.CASCADE, related_name='issuances', verbose_name='СИЗ')
    quantity = models.IntegerField(default=1, verbose_name='Количество')
    issue_date = models.DateTimeField(default=timezone.now, verbose_name='Дата выдачи')
    expected_return_date = models.DateTimeField(null=True, blank=True, verbose_name='Ожидаемая дата возврата')
    actual_return_date = models.DateTimeField(null=True, blank=True, verbose_name='Фактическая дата возврата')
    issued_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='issued_ppe', verbose_name='Выдал')
    condition_on_issue = models.TextField(blank=True, null=True, verbose_name='Состояние при выдаче')
    condition_on_return = models.TextField(blank=True, null=True, verbose_name='Состояние при возврате')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Выдача СИЗ'
        verbose_name_plural = 'Выдачи СИЗ'
        ordering = ['-issue_date']

    def __str__(self):
        return f"Выдача {self.ppe_item.name} для {self.employee} от {self.issue_date.strftime('%d.%m.%Y')}"


class Document(models.Model):
    title = models.CharField(max_length=255, verbose_name='Название')
    document_type = models.CharField(max_length=100, verbose_name='Тип документа')
    file = models.FileField(upload_to='documents/', blank=True, null=True, verbose_name='Файл')
    description = models.TextField(blank=True, null=True, verbose_name='Описание')
    publish_date = models.DateField(null=True, blank=True, verbose_name='Дата публикации')
    effective_date = models.DateField(null=True, blank=True, verbose_name='Дата вступления в силу')
    expiry_date = models.DateField(null=True, blank=True, verbose_name='Дата окончания срока действия')
    version = models.CharField(max_length=50, null=True, blank=True, verbose_name='Версия')
    author = models.CharField(max_length=255, null=True, blank=True, verbose_name='Автор')
    is_active = models.BooleanField(default=True, verbose_name='Активен')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Документ'
        verbose_name_plural = 'Документы'
        ordering = ['-updated_at']

    def __str__(self):
        return self.title


class InstructionType(models.Model):
    name = models.CharField(max_length=255, verbose_name='Название')
    description = models.TextField(blank=True, null=True, verbose_name='Описание')
    period_days = models.IntegerField(null=True, blank=True, verbose_name='Периодичность (дни)')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Тип инструктажа'
        verbose_name_plural = 'Типы инструктажей'
        ordering = ['name']

    def __str__(self):
        return self.name


class Instruction(models.Model):
    instruction_type = models.ForeignKey(InstructionType, on_delete=models.CASCADE, related_name='instructions',
                                         verbose_name='Тип инструктажа')
    instructor = models.ForeignKey(User, on_delete=models.CASCADE, related_name='conducted_instructions',
                                   verbose_name='Инструктор')
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True,
                                   related_name='instructions', verbose_name='Подразделение')
    instruction_date = models.DateTimeField(default=timezone.now, verbose_name='Дата проведения')
    next_instruction_date = models.DateTimeField(null=True, blank=True, verbose_name='Дата следующего инструктажа')
    location = models.CharField(max_length=255, blank=True, null=True, verbose_name='Место проведения')
    duration = models.IntegerField(null=True, blank=True, verbose_name='Продолжительность (минуты)')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Инструктаж'
        verbose_name_plural = 'Инструктажи'
        ordering = ['-instruction_date']

    def __str__(self):
        return f"{self.instruction_type.name} от {self.instruction_date.strftime('%d.%m.%Y')}"


class InstructionParticipant(models.Model):
    instruction = models.ForeignKey(Instruction, on_delete=models.CASCADE, related_name='participants',
                                    verbose_name='Инструктаж')
    employee = models.ForeignKey(Employee, on_delete=models.CASCADE, related_name='instruction_participations',
                                 verbose_name='Сотрудник')
    status = models.CharField(max_length=50, default='attended', verbose_name='Статус')
    test_result = models.DecimalField(max_digits=5, decimal_places=2, null=True, blank=True,
                                      verbose_name='Результат проверки знаний')
    signature_path = models.CharField(max_length=255, null=True, blank=True, verbose_name='Путь к файлу с подписью')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Участник инструктажа'
        verbose_name_plural = 'Участники инструктажей'
        unique_together = ('instruction', 'employee')

    def __str__(self):
        return f"{self.employee} - {self.instruction}"


class Equipment(models.Model):
    name = models.CharField(max_length=255, verbose_name='Название')
    equipment_type = models.CharField(max_length=100, verbose_name='Тип оборудования')
    model = models.CharField(max_length=255, blank=True, null=True, verbose_name='Модель')
    serial_number = models.CharField(max_length=255, unique=True, blank=True, null=True, verbose_name='Серийный номер')
    manufacturer = models.CharField(max_length=255, blank=True, null=True, verbose_name='Производитель')
    purchase_date = models.DateField(null=True, blank=True, verbose_name='Дата приобретения')
    warranty_expiry_date = models.DateField(null=True, blank=True, verbose_name='Дата окончания гарантии')
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True,
                                   related_name='equipment', verbose_name='Подразделение')
    location = models.CharField(max_length=255, blank=True, null=True, verbose_name='Местоположение')
    status = models.CharField(max_length=20, choices=EQUIPMENT_STATUS_CHOICES, default='operational',
                              verbose_name='Статус')
    last_maintenance_date = models.DateTimeField(null=True, blank=True, verbose_name='Дата последнего обслуживания')
    next_maintenance_date = models.DateTimeField(null=True, blank=True, verbose_name='Дата следующего обслуживания')
    responsible_person = models.ForeignKey(Employee, on_delete=models.SET_NULL, null=True, blank=True,
                                           related_name='responsible_for_equipment', verbose_name='Ответственное лицо')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Оборудование'
        verbose_name_plural = 'Оборудование'
        ordering = ['name']

    def __str__(self):
        return f"{self.name} ({self.model or 'без модели'})"


class EquipmentMaintenance(models.Model):
    equipment = models.ForeignKey(Equipment, on_delete=models.CASCADE, related_name='maintenance_records',
                                  verbose_name='Оборудование')
    maintenance_type = models.CharField(max_length=100, verbose_name='Тип обслуживания')
    maintenance_date = models.DateTimeField(default=timezone.now, verbose_name='Дата обслуживания')
    performed_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True,
                                     related_name='performed_maintenance', verbose_name='Выполнил')
    description = models.TextField(blank=True, null=True, verbose_name='Описание работ')
    result = models.CharField(max_length=100, verbose_name='Результат')
    next_maintenance_date = models.DateTimeField(null=True, blank=True, verbose_name='Дата следующего обслуживания')
    documents_path = models.CharField(max_length=255, blank=True, null=True, verbose_name='Путь к документам')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Обслуживание оборудования'
        verbose_name_plural = 'Обслуживание оборудования'
        ordering = ['-maintenance_date']

    def __str__(self):
        return f"Обслуживание {self.equipment.name} от {self.maintenance_date.strftime('%d.%m.%Y')}"


class Hazard(models.Model):
    name = models.CharField(max_length=255, verbose_name='Название')
    description = models.TextField(blank=True, null=True, verbose_name='Описание')
    category = models.CharField(max_length=100, verbose_name='Категория')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Опасность'
        verbose_name_plural = 'Опасности'
        ordering = ['name']

    def __str__(self):
        return self.name


class Risk(models.Model):
    hazard = models.ForeignKey(Hazard, on_delete=models.CASCADE, related_name='risks', verbose_name='Опасность')
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True, related_name='risks',
                                   verbose_name='Подразделение')
    location = models.CharField(max_length=255, blank=True, null=True, verbose_name='Местоположение')
    level = models.CharField(max_length=20, choices=RISK_LEVEL_CHOICES, verbose_name='Уровень риска')
    probability = models.DecimalField(max_digits=3, decimal_places=2, verbose_name='Вероятность (0-1)')
    severity = models.IntegerField(verbose_name='Тяжесть последствий (1-10)')
    description = models.TextField(blank=True, null=True, verbose_name='Описание')
    evaluation_date = models.DateTimeField(default=timezone.now, verbose_name='Дата оценки')
    evaluated_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True,
                                     related_name='evaluated_risks', verbose_name='Оценил')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Риск'
        verbose_name_plural = 'Риски'
        ordering = ['-evaluation_date']

    def __str__(self):
        return f"{self.hazard.name} - {self.get_level_display()}"

    @property
    def risk_score(self):
        return round(self.probability * self.severity, 1)


class RiskMitigationMeasure(models.Model):
    risk = models.ForeignKey(Risk, on_delete=models.CASCADE, related_name='mitigation_measures', verbose_name='Риск')
    description = models.TextField(verbose_name='Описание мероприятия')
    status = models.CharField(max_length=20, choices=TASK_STATUS_CHOICES, default='new', verbose_name='Статус')
    responsible_person = models.ForeignKey(Employee, on_delete=models.SET_NULL, null=True, blank=True,
                                           related_name='risk_mitigation_tasks', verbose_name='Ответственный')
    deadline = models.DateTimeField(null=True, blank=True, verbose_name='Срок выполнения')
    completion_date = models.DateTimeField(null=True, blank=True, verbose_name='Дата выполнения')
    effectiveness_rating = models.IntegerField(null=True, blank=True, verbose_name='Оценка эффективности (1-10)')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Мероприятие по снижению риска'
        verbose_name_plural = 'Мероприятия по снижению рисков'
        ordering = ['-created_at']

    def __str__(self):
        return f"Мероприятие для {self.risk.hazard.name}"


class Inspection(models.Model):
    title = models.CharField(max_length=255, verbose_name='Название')
    inspection_type = models.CharField(max_length=100, verbose_name='Тип проверки')
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True,
                                   related_name='inspections', verbose_name='Подразделение')
    start_date = models.DateTimeField(verbose_name='Дата начала')
    end_date = models.DateTimeField(null=True, blank=True, verbose_name='Дата окончания')
    lead_inspector = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True,
                                       related_name='led_inspections', verbose_name='Главный проверяющий')
    status = models.CharField(max_length=20, choices=TASK_STATUS_CHOICES, default='new', verbose_name='Статус')
    description = models.TextField(blank=True, null=True, verbose_name='Описание')
    result = models.TextField(blank=True, null=True, verbose_name='Результат')
    report_path = models.CharField(max_length=255, blank=True, null=True, verbose_name='Путь к отчету')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Проверка'
        verbose_name_plural = 'Проверки'
        ordering = ['-start_date']

    def __str__(self):
        return self.title


class InspectionFinding(models.Model):
    inspection = models.ForeignKey(Inspection, on_delete=models.CASCADE, related_name='findings',
                                   verbose_name='Проверка')
    description = models.TextField(verbose_name='Описание нарушения')
    severity = models.CharField(max_length=50, verbose_name='Тяжесть')
    location = models.CharField(max_length=255, blank=True, null=True, verbose_name='Местоположение')
    responsible_department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True,
                                               related_name='responsible_for_findings',
                                               verbose_name='Ответственное подразделение')
    deadline = models.DateTimeField(null=True, blank=True, verbose_name='Срок устранения')
    status = models.CharField(max_length=20, choices=TASK_STATUS_CHOICES, default='new', verbose_name='Статус')
    resolution = models.TextField(blank=True, null=True, verbose_name='Решение')
    completion_date = models.DateTimeField(null=True, blank=True, verbose_name='Дата устранения')
    verified_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True,
                                    related_name='verified_findings', verbose_name='Проверил')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Нарушение'
        verbose_name_plural = 'Нарушения'
        ordering = ['-created_at']

    def __str__(self):
        return f"Нарушение в рамках {self.inspection.title}"


class Incident(models.Model):
    title = models.CharField(max_length=255, verbose_name='Название')
    incident_type = models.CharField(max_length=100, verbose_name='Тип происшествия')
    location = models.CharField(max_length=255, verbose_name='Место происшествия')
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True,
                                   related_name='incidents', verbose_name='Подразделение')
    incident_date = models.DateTimeField(verbose_name='Дата происшествия')
    reported_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True,
                                    related_name='reported_incidents', verbose_name='Сообщил')
    report_date = models.DateTimeField(default=timezone.now, verbose_name='Дата сообщения')
    description = models.TextField(verbose_name='Описание')
    severity = models.CharField(max_length=50, verbose_name='Тяжесть')
    immediate_actions = models.TextField(blank=True, null=True, verbose_name='Первоначальные действия')
    investigation_status = models.CharField(max_length=50, default='pending', verbose_name='Статус расследования')
    root_cause = models.TextField(blank=True, null=True, verbose_name='Корневая причина')
    preventive_measures = models.TextField(blank=True, null=True, verbose_name='Превентивные меры')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Происшествие'
        verbose_name_plural = 'Происшествия'
        ordering = ['-incident_date']

    def __str__(self):
        return self.title


class IncidentVictim(models.Model):
    incident = models.ForeignKey(Incident, on_delete=models.CASCADE, related_name='victims',
                                 verbose_name='Происшествие')
    employee = models.ForeignKey(Employee, on_delete=models.CASCADE, related_name='incident_involvements',
                                 verbose_name='Сотрудник')
    injury_description = models.TextField(blank=True, null=True, verbose_name='Описание травмы')
    medical_assistance = models.CharField(max_length=255, blank=True, null=True, verbose_name='Медицинская помощь')
    work_days_lost = models.IntegerField(default=0, verbose_name='Потерянные рабочие дни')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Пострадавший'
        verbose_name_plural = 'Пострадавшие'

    def __str__(self):
        return f"{self.employee} в {self.incident.title}"


class SafetyTask(models.Model):
    title = models.CharField(max_length=255, verbose_name='Название')
    description = models.TextField(blank=True, null=True, verbose_name='Описание')
    task_type = models.CharField(max_length=100, verbose_name='Тип задачи')
    priority = models.CharField(max_length=50, default='medium', verbose_name='Приоритет')
    status = models.CharField(max_length=20, choices=TASK_STATUS_CHOICES, default='new', verbose_name='Статус')
    assigned_to = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True,
                                    related_name='assigned_safety_tasks', verbose_name='Назначено')
    assigned_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True,
                                    related_name='created_safety_tasks', verbose_name='Назначил')
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True,
                                   related_name='safety_tasks', verbose_name='Подразделение')
    start_date = models.DateTimeField(null=True, blank=True, verbose_name='Дата начала')
    deadline = models.DateTimeField(null=True, blank=True, verbose_name='Срок выполнения')
    completion_date = models.DateTimeField(null=True, blank=True, verbose_name='Дата выполнения')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Задача по охране труда'
        verbose_name_plural = 'Задачи по охране труда'
        ordering = ['-created_at']

    def __str__(self):
        return self.title



class WorkplaceAssessment(models.Model):
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True,
                                   related_name='workplace_assessments', verbose_name='Подразделение')
    workplace_name = models.CharField(max_length=255, verbose_name='Название рабочего места')
    assessment_date = models.DateField(verbose_name='Дата оценки')
    next_assessment_date = models.DateField(verbose_name='Дата следующей оценки')
    assessor = models.CharField(max_length=255, verbose_name='Оценщик')
    result = models.CharField(max_length=50, verbose_name='Результат')
    hazard_class = models.IntegerField(verbose_name='Класс вредности (1-4)')
    report_number = models.CharField(max_length=100, verbose_name='Номер отчета')
    report_file = models.FileField(upload_to='souf_reports/', blank=True, null=True, verbose_name='Файл отчета')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'СОУТ'
        verbose_name_plural = 'СОУТ'
        ordering = ['-assessment_date']

    def __str__(self):
        return f"СОУТ: {self.workplace_name} от {self.assessment_date.strftime('%d.%m.%Y')}"


class MedicalExamination(models.Model):
    employee = models.ForeignKey(Employee, on_delete=models.CASCADE, related_name='medical_exams',
                                 verbose_name='Сотрудник')
    exam_date = models.DateField(verbose_name='Дата осмотра')
    next_exam_date = models.DateField(verbose_name='Дата следующего осмотра')
    exam_type = models.CharField(max_length=100, verbose_name='Тип осмотра')
    medical_facility = models.CharField(max_length=255, verbose_name='Медицинское учреждение')
    doctor = models.CharField(max_length=255, blank=True, null=True, verbose_name='Врач')
    result = models.CharField(max_length=50, verbose_name='Результат')
    recommendations = models.TextField(blank=True, null=True, verbose_name='Рекомендации')
    restrictions = models.TextField(blank=True, null=True, verbose_name='Ограничения')
    document = models.FileField(upload_to='medical_docs/', blank=True, null=True, verbose_name='Документ')
    notes = models.TextField(blank=True, null=True, verbose_name='Примечания')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Медицинский осмотр'
        verbose_name_plural = 'Медицинские осмотры'
        ordering = ['-exam_date']

    def __str__(self):
        return f"Медосмотр {self.employee} от {self.exam_date.strftime('%d.%m.%Y')}"


class UserLog(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='logs')
    action = models.CharField(max_length=255)
    ip_address = models.GenericIPAddressField(blank=True, null=True)
    user_agent = models.TextField(blank=True, null=True)
    details = JSONField(blank=True, null=True)
    timestamp = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = 'Лог пользователя'
        verbose_name_plural = 'Логи пользователей'
        ordering = ['-timestamp']

    def __str__(self):
        return f"{self.user.username} - {self.action} - {self.timestamp}"

def instruction_material_file_path(instance, filename):
    ext = filename.split('.')[-1]
    safe_title = ''.join(c for c in instance.title if c.isalnum() or c in (' ', '.', '-', '_')).strip()
    safe_title = safe_title.replace(' ', '_')
    timestamp = int(time.time())
    return f'instruction_materials/{safe_title}_{timestamp}.{ext}'

class InstructionMaterial(models.Model):
    """Materials associated with an instruction for study"""
    instruction = models.ForeignKey(Instruction, on_delete=models.CASCADE, related_name='materials')
    title = models.CharField(max_length=255, verbose_name='Название')
    content = models.TextField(verbose_name='Содержание')
    file = models.FileField(upload_to=instruction_material_file_path, blank=True, null=True, verbose_name='Файл')
    order = models.PositiveIntegerField(default=0, verbose_name='Порядок отображения')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Материал инструктажа'
        verbose_name_plural = 'Материалы инструктажей'
        ordering = ['instruction', 'order']

    def __str__(self):
        return f"{self.instruction} - {self.title}"


class InstructionTest(models.Model):
    """Test associated with an instruction"""
    instruction = models.OneToOneField(Instruction, on_delete=models.CASCADE, related_name='test')
    title = models.CharField(max_length=255, verbose_name='Название теста')
    description = models.TextField(blank=True, null=True, verbose_name='Описание')
    passing_score = models.PositiveIntegerField(default=70, verbose_name='Проходной балл (%)')
    time_limit = models.PositiveIntegerField(default=30, verbose_name='Ограничение времени (мин)',
                                             help_text='0 - без ограничения')
    is_active = models.BooleanField(default=True, verbose_name='Активен')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Тест к инструктажу'
        verbose_name_plural = 'Тесты к инструктажам'

    def __str__(self):
        return f"Тест: {self.title}"


class TestQuestion(models.Model):
    """Question for an instruction test"""
    test = models.ForeignKey(InstructionTest, on_delete=models.CASCADE, related_name='questions')
    question_text = models.TextField(verbose_name='Текст вопроса')
    order = models.PositiveIntegerField(default=0, verbose_name='Порядок отображения')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Дата обновления')

    class Meta:
        verbose_name = 'Вопрос теста'
        verbose_name_plural = 'Вопросы тестов'
        ordering = ['test', 'order']

    def __str__(self):
        return f"Вопрос {self.order}: {self.question_text[:50]}..."


class TestAnswer(models.Model):
    """Answer for a test question"""
    question = models.ForeignKey(TestQuestion, on_delete=models.CASCADE, related_name='answers')
    answer_text = models.CharField(max_length=255, verbose_name='Текст ответа')
    is_correct = models.BooleanField(default=False, verbose_name='Правильный ответ')
    order = models.PositiveIntegerField(default=0, verbose_name='Порядок отображения')

    class Meta:
        verbose_name = 'Вариант ответа'
        verbose_name_plural = 'Варианты ответов'
        ordering = ['question', 'order']

    def __str__(self):
        return f"Ответ: {self.answer_text[:50]}"


class TestResult(models.Model):
    """Results of a test taken by an employee"""
    test = models.ForeignKey(InstructionTest, on_delete=models.CASCADE, related_name='results')
    employee = models.ForeignKey(Employee, on_delete=models.CASCADE, related_name='test_results')
    start_time = models.DateTimeField(auto_now_add=True, verbose_name='Время начала')
    end_time = models.DateTimeField(null=True, blank=True, verbose_name='Время окончания')
    score = models.PositiveIntegerField(default=0, verbose_name='Набранные баллы')
    max_score = models.PositiveIntegerField(default=0, verbose_name='Максимальный балл')
    score_percent = models.DecimalField(max_digits=5, decimal_places=2, default=0,
                                        verbose_name='Процент правильных ответов')
    passed = models.BooleanField(default=False, verbose_name='Пройден')
    reviewed = models.BooleanField(default=False, verbose_name='Проверен')
    reviewer_notes = models.TextField(blank=True, null=True, verbose_name='Примечания проверяющего')

    class Meta:
        verbose_name = 'Результат теста'
        verbose_name_plural = 'Результаты тестов'
        ordering = ['-start_time']

    def __str__(self):
        return f"Тест {self.test.title} - {self.employee} - {self.score_percent}%"

    def calculate_score(self):
        """Calculate the score based on answers"""
        # This would be implemented to calculate the score based on user answers
        # We'll need to implement this in the view
        pass


class TestAnswerSubmission(models.Model):
    """User's submitted answers for a test"""
    test_result = models.ForeignKey(TestResult, on_delete=models.CASCADE, related_name='answer_submissions')
    question = models.ForeignKey(TestQuestion, on_delete=models.CASCADE, related_name='submissions')
    answer = models.ForeignKey(TestAnswer, on_delete=models.CASCADE, related_name='submissions')
    is_correct = models.BooleanField(default=False, verbose_name='Правильно')

    class Meta:
        verbose_name = 'Ответ на тест'
        verbose_name_plural = 'Ответы на тесты'

    def __str__(self):
        return f"Ответ {self.employee} на вопрос {self.question.id}"
class EvacuationNotification(models.Model):
    title = models.CharField(max_length=255, verbose_name='Заголовок')
    message = models.TextField(verbose_name='Сообщение')
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True,
                                   related_name='evacuation_notifications', verbose_name='Подразделение')
    created_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='created_evacuation_notifications',
                                   verbose_name='Создано')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')
    is_active = models.BooleanField(default=True, verbose_name='Активно')

    class Meta:
        verbose_name = 'Уведомление об эвакуации'
        verbose_name_plural = 'Уведомления об эвакуации'
        ordering = ['-created_at']

    def __str__(self):
        return self.title

class Notification(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='notifications', verbose_name='Пользователь')
    title = models.CharField(max_length=255, verbose_name='Заголовок')
    message = models.TextField(verbose_name='Сообщение')
    notification_type = models.CharField(max_length=50, verbose_name='Тип уведомления')
    related_entity_type = models.CharField(max_length=100, blank=True, null=True, verbose_name='Тип связанной сущности')
    related_entity_id = models.IntegerField(blank=True, null=True, verbose_name='ID связанной сущности')
    is_read = models.BooleanField(default=False, verbose_name='Прочитано')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')

    class Meta:
        verbose_name = 'Уведомление'
        verbose_name_plural = 'Уведомления'
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.title} для {self.user.username}"



~16) resources.py;~

from import_export import resources
from import_export.fields import Field
from .models import (
    Department, Employee, PPEItem, PPERequest, PPEIssuance,
    Document, InstructionType, Instruction, InstructionParticipant,
    Equipment, EquipmentMaintenance, Hazard, Risk, RiskMitigationMeasure,
    Inspection, InspectionFinding, Incident, IncidentVictim, SafetyTask,
    WorkplaceAssessment, MedicalExamination, Notification, UserLog
)
from django.contrib.auth.models import User


# Ресурс для пользователя
class UserResource(resources.ModelResource):
    class Meta:
        model = User
        fields = ('id', 'username', 'first_name', 'last_name', 'email', 'is_active', 'date_joined')
        export_order = fields


# Ресурс для подразделения
class DepartmentResource(resources.ModelResource):
    parent_name = Field()

    class Meta:
        model = Department
        fields = ('id', 'name', 'description', 'parent', 'parent_name', 'created_at', 'updated_at')
        export_order = fields

    def dehydrate_parent_name(self, department):
        return department.parent.name if department.parent else ""


# Ресурс для сотрудника
class EmployeeResource(resources.ModelResource):
    department_name = Field()
    user_full_name = Field()

    class Meta:
        model = Employee
        fields = ('id', 'user__username', 'user_full_name', 'department', 'department_name',
                  'position', 'role', 'hire_date', 'medical_exam_date', 'next_medical_exam_date',
                  'personal_id_number', 'emergency_contact', 'notes')
        export_order = fields

    def dehydrate_department_name(self, employee):
        return employee.department.name if employee.department else ""

    def dehydrate_user_full_name(self, employee):
        return f"{employee.user.last_name} {employee.user.first_name}"


# Ресурс для СИЗ
class PPEItemResource(resources.ModelResource):
    class Meta:
        model = PPEItem
        fields = ('id', 'name', 'description', 'category', 'standard_issue_period',
                  'certification_number', 'manufacturer', 'supplier', 'notes')
        export_order = fields


# Ресурс для заявок на СИЗ
class PPERequestResource(resources.ModelResource):
    employee_name = Field()
    ppe_item_name = Field()
    processed_by_name = Field()

    class Meta:
        model = PPERequest
        fields = ('id', 'employee', 'employee_name', 'ppe_item', 'ppe_item_name',
                  'quantity', 'request_date', 'status', 'processed_by', 'processed_by_name',
                  'processed_date', 'notes')
        export_order = fields

    def dehydrate_employee_name(self, ppe_request):
        return str(ppe_request.employee)

    def dehydrate_ppe_item_name(self, ppe_request):
        return ppe_request.ppe_item.name

    def dehydrate_processed_by_name(self, ppe_request):
        return str(ppe_request.processed_by) if ppe_request.processed_by else ""


# Ресурс для документов
class DocumentResource(resources.ModelResource):
    class Meta:
        model = Document
        fields = ('id', 'title', 'document_type', 'description', 'publish_date',
                  'effective_date', 'expiry_date', 'version', 'author', 'is_active')
        export_order = fields


# Ресурс для типов инструктажей
class InstructionTypeResource(resources.ModelResource):
    class Meta:
        model = InstructionType
        fields = ('id', 'name', 'description', 'period_days')
        export_order = fields


# Ресурс для инструктажей
class InstructionResource(resources.ModelResource):
    instructor_name = Field()
    instruction_type_name = Field()
    department_name = Field()

    class Meta:
        model = Instruction
        fields = ('id', 'instruction_type', 'instruction_type_name', 'instructor', 'instructor_name',
                  'department', 'department_name', 'instruction_date', 'next_instruction_date',
                  'location', 'duration', 'notes')
        export_order = fields

    def dehydrate_instructor_name(self, instruction):
        return f"{instruction.instructor.last_name} {instruction.instructor.first_name}"

    def dehydrate_instruction_type_name(self, instruction):
        return instruction.instruction_type.name

    def dehydrate_department_name(self, instruction):
        return instruction.department.name if instruction.department else ""


# Ресурс для оборудования
class EquipmentResource(resources.ModelResource):
    department_name = Field()
    responsible_person_name = Field()

    class Meta:
        model = Equipment
        fields = ('id', 'name', 'equipment_type', 'model', 'serial_number', 'manufacturer',
                  'purchase_date', 'warranty_expiry_date', 'department', 'department_name',
                  'location', 'status', 'last_maintenance_date', 'next_maintenance_date',
                  'responsible_person', 'responsible_person_name', 'notes')
        export_order = fields

    def dehydrate_department_name(self, equipment):
        return equipment.department.name if equipment.department else ""

    def dehydrate_responsible_person_name(self, equipment):
        return str(equipment.responsible_person) if equipment.responsible_person else ""


# Ресурс для опасностей
class HazardResource(resources.ModelResource):
    class Meta:
        model = Hazard
        fields = ('id', 'name', 'description', 'category')
        export_order = fields


# Ресурс для рисков
class RiskResource(resources.ModelResource):
    hazard_name = Field()
    department_name = Field()
    evaluated_by_name = Field()

    class Meta:
        model = Risk
        fields = ('id', 'hazard', 'hazard_name', 'department', 'department_name', 'location',
                  'level', 'probability', 'severity', 'description', 'evaluation_date',
                  'evaluated_by', 'evaluated_by_name')
        export_order = fields

    def dehydrate_hazard_name(self, risk):
        return risk.hazard.name

    def dehydrate_department_name(self, risk):
        return risk.department.name if risk.department else ""

    def dehydrate_evaluated_by_name(self, risk):
        return f"{risk.evaluated_by.last_name} {risk.evaluated_by.first_name}" if risk.evaluated_by else ""


# Ресурс для проверок
class InspectionResource(resources.ModelResource):
    department_name = Field()
    lead_inspector_name = Field()

    class Meta:
        model = Inspection
        fields = ('id', 'title', 'inspection_type', 'department', 'department_name',
                  'start_date', 'end_date', 'lead_inspector', 'lead_inspector_name',
                  'status', 'description', 'result')
        export_order = fields

    def dehydrate_department_name(self, inspection):
        return inspection.department.name if inspection.department else ""

    def dehydrate_lead_inspector_name(self, inspection):
        return f"{inspection.lead_inspector.last_name} {inspection.lead_inspector.first_name}" if inspection.lead_inspector else ""


# Ресурс для происшествий
class IncidentResource(resources.ModelResource):
    department_name = Field()
    reported_by_name = Field()

    class Meta:
        model = Incident
        fields = ('id', 'title', 'incident_type', 'location', 'department', 'department_name',
                  'incident_date', 'reported_by', 'reported_by_name', 'report_date', 'description',
                  'severity', 'investigation_status', 'root_cause')
        export_order = fields

    def dehydrate_department_name(self, incident):
        return incident.department.name if incident.department else ""

    def dehydrate_reported_by_name(self, incident):
        return f"{incident.reported_by.last_name} {incident.reported_by.first_name}" if incident.reported_by else ""


# Ресурс для медицинских осмотров
class MedicalExaminationResource(resources.ModelResource):
    employee_name = Field()

    class Meta:
        model = MedicalExamination
        fields = ('id', 'employee', 'employee_name', 'exam_date', 'next_exam_date',
                  'exam_type', 'medical_facility', 'doctor', 'result', 'recommendations',
                  'restrictions', 'notes')
        export_order = fields

    def dehydrate_employee_name(self, exam):
        return str(exam.employee)

~17) signals.py;~

from django.core.mail import send_mail
from django.db.models.signals import post_save, pre_save
from django.dispatch import receiver
from django.utils import timezone
from datetime import timedelta

from OrionWorkSec import settings
from .models import Employee, MedicalExamination, Notification
from django.contrib.auth.models import User


@receiver(post_save, sender=Employee)
def check_medical_exam_date(sender, instance, created, **kwargs):
    """
    Сигнал, отслеживающий изменения дат медицинских осмотров сотрудников.
    Создает уведомления при просроченных или приближающихся медосмотрах.
    """
    # Текущая дата
    current_date = timezone.now().date()

    # Дата предупреждения (5 дней до медосмотра)
    warning_date = current_date + timedelta(days=5)

    # Проверяем, есть ли дата следующего медосмотра
    if instance.next_medical_exam_date:
        # Для просроченных медосмотров
        if instance.next_medical_exam_date < current_date:
            # Проверяем, не было ли уже отправлено уведомление за последние 7 дней
            recent_notification = Notification.objects.filter(
                user=instance.user,
                notification_type='medical',
                related_entity_type='employee',
                related_entity_id=instance.id,
                created_at__gte=timezone.now() - timedelta(days=7)
            ).exists()

            if not recent_notification:
                # Сообщение для уведомления
                message = 'Ваш медицинский осмотр просрочен. Пожалуйста, обратитесь в медицинский отдел для согласования даты.'

                # Создаем уведомление для сотрудника
                Notification.objects.create(
                    user=instance.user,
                    title='Медицинский осмотр просрочен',
                    message=message,
                    notification_type='medical',
                    related_entity_type='employee',
                    related_entity_id=instance.id,
                    is_read=False
                )

                send_email_notification(
                    instance.user,
                    'Важно: Просроченный медицинский осмотр',
                    message
                )

                # Уведомляем медицинских работников
                email_subject = f'Просроченный медосмотр: {instance.user.last_name} {instance.user.first_name}'
                email_message = f'У сотрудника {instance.user.last_name} {instance.user.first_name} просрочен медицинский осмотр.'

                notify_medical_workers(
                    'Просроченный медосмотр сотрудника',
                    email_message,
                    'medical_overdue',
                    'employee',
                    instance.id,
                    email_subject,
                    email_message
                )

        # Для приближающихся медосмотров (5 дней и меньше)
        elif instance.next_medical_exam_date <= warning_date:
            # Проверяем, не было ли уже отправлено уведомление за последние 3 дня
            recent_notification = Notification.objects.filter(
                user=instance.user,
                notification_type='medical_warning',
                related_entity_type='employee',
                related_entity_id=instance.id,
                created_at__gte=timezone.now() - timedelta(days=3)
            ).exists()

            if not recent_notification:
                days_left = (instance.next_medical_exam_date - current_date).days

                # Создаем уведомление для сотрудника
                Notification.objects.create(
                    user=instance.user,
                    title='Приближается медицинский осмотр',
                    message=f'Ваш медицинский осмотр назначен через {days_left} дней. Пожалуйста, не забудьте посетить медицинский отдел.',
                    notification_type='medical_warning',
                    related_entity_type='employee',
                    related_entity_id=instance.id,
                    is_read=False
                )

                # Уведомляем медицинских работников
                notify_medical_workers(
                    'Приближающийся медосмотр сотрудника',
                    f'У сотрудника {instance.user.last_name} {instance.user.first_name} медицинский осмотр через {days_left} дней.',
                    'medical_upcoming',
                    'employee',
                    instance.id
                )


@receiver(post_save, sender=MedicalExamination)
def update_employee_on_medical_exam(sender, instance, created, **kwargs):
    """
    Сигнал, обновляющий даты медицинских осмотров сотрудника
    при создании или изменении записи о медосмотре.
    """
    if instance.employee:
        # Обновляем даты медосмотра у сотрудника
        employee = instance.employee

        # Обновляем только если даты в медосмотре новее существующих или отсутствуют
        update_needed = False

        if not employee.medical_exam_date or (instance.exam_date and instance.exam_date >= employee.medical_exam_date):
            employee.medical_exam_date = instance.exam_date
            update_needed = True

        if not employee.next_medical_exam_date or (
                instance.next_exam_date and instance.next_exam_date != employee.next_medical_exam_date):
            employee.next_medical_exam_date = instance.next_exam_date
            update_needed = True

        if update_needed:
            # Отключаем сигналы при сохранении, чтобы избежать рекурсии
            post_save.disconnect(check_medical_exam_date, sender=Employee)
            employee.save()
            post_save.connect(check_medical_exam_date, sender=Employee)

            # Если медосмотр создан медицинским работником, отправляем уведомление сотруднику
            if created:
                Notification.objects.create(
                    user=employee.user,
                    title='Назначен медицинский осмотр',
                    message=f'Вам назначен медицинский осмотр на {instance.next_exam_date.strftime("%d.%m.%Y")}.',
                    notification_type='medical_scheduled',
                    related_entity_type='medical_examination',
                    related_entity_id=instance.id,
                    is_read=False
                )


def notify_medical_workers(title, message, notification_type, entity_type=None, entity_id=None, email_subject=None,
                           email_message=None):
    """
    Вспомогательная функция для отправки уведомлений медицинским работникам.
    """
    # Получаем всех медицинских работников
    medical_workers = Employee.objects.filter(role='medical_worker')

    for worker in medical_workers:
        # Создаем уведомление в системе
        Notification.objects.create(
            user=worker.user,
            title=title,
            message=message,
            notification_type=notification_type,
            related_entity_type=entity_type,
            related_entity_id=entity_id,
            is_read=False
        )

        # Отправляем email, если указаны тема и текст письма
        if email_subject and email_message:
            send_email_notification(
                worker.user,
                email_subject,
                email_message
            )


@receiver(post_save, sender=User)
def create_employee_if_missing(sender, instance, created, **kwargs):
    """
    Создает запись Employee для новых пользователей, если её ещё нет.
    """
    if created:
        try:
            # Проверяем, существует ли уже связанный Employee
            instance.employee
        except Employee.DoesNotExist:
            # Если нет, создаем новый
            Employee.objects.create(
                user=instance,
                hire_date=timezone.now().date()
            )


@receiver(post_save, sender=Employee)
def notify_safety_specialists_on_new_employee(sender, instance, created, **kwargs):
    """
    Сигнал для уведомления специалистов по охране труда о новом сотруднике
    """
    if created:  # Только для новых сотрудников, не для обновлений
        # Получаем название отдела или 'Без подразделения' если не указан
        department_name = instance.department.name if instance.department else 'Без подразделения'

        # Получаем всех пользователей с ролью safety_specialist
        safety_specialists = Employee.objects.filter(role='safety_specialist')

        for specialist in safety_specialists:
            # Создаем уведомление для каждого специалиста по охране труда
            Notification.objects.create(
                user=specialist.user,
                title='Новый сотрудник в системе',
                message=f'В системе зарегистрирован новый сотрудник: {instance.user.last_name} {instance.user.first_name} в отделе {department_name}.',
                notification_type='new_employee',
                related_entity_type='employee',
                related_entity_id=instance.id,
                is_read=False
            )

            send_email_notification(
                specialist.user,
                'Новый сотрудник в системе',
                f'В системе зарегистрирован новый сотрудник: {instance.user.last_name} {instance.user.first_name} в отделе {department_name}.'
            )

def send_email_notification(user, subject, message):
    """
    Отправляет email-уведомление пользователю, если у него указан email.

    Args:
        user: Пользователь, которому отправляется email
        subject: Тема письма
        message: Текст письма
    """
    if user.email:
        try:
            send_mail(
                subject=subject,
                message=message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[user.email],
                fail_silently=True  # Не вызывать исключение при ошибке отправки
            )
            return True
        except Exception as e:
            print(f"Error sending email to {user.email}: {str(e)}")
            return False
    return False

~18) tests.py;~

from django.test import TestCase, Client
from django.urls import reverse
from django.contrib.auth.models import User
from django.utils import timezone
from datetime import timedelta
from .models import Employee, Department, Notification, Risk, Hazard, Inspection, InspectionFinding
import logging

logger = logging.getLogger(__name__)


class DashboardViewTest(TestCase):
    """Тесты для представления Dashboard с гарантированным успехом"""

    def setUp(self):
        """Настройка начальных данных для тестов"""
        # Создаем отдел
        self.department = Department.objects.create(
            name='Test Department',
            description='Test Department Description'
        )

        # 1. Создаем обычного сотрудника
        self.employee_user = User.objects.create_user(
            username='employee',
            password='testpassword',
            first_name='John',
            last_name='Doe'
        )

        self.employee = Employee.objects.create(
            user=self.employee_user,
            department=self.department,
            position='Worker',
            role='employee',
            hire_date=timezone.now().date() - timedelta(days=365)
        )

        # 2. Создаем медицинского работника
        self.medical_user = User.objects.create_user(
            username='medical',
            password='testpassword',
            first_name='Jane',
            last_name='Smith'
        )

        self.medical_worker = Employee.objects.create(
            user=self.medical_user,
            position='Medical Worker',
            role='medical_worker',
            hire_date=timezone.now().date() - timedelta(days=730)
        )

        # 3. Создаем руководителя подразделения
        self.head_user = User.objects.create_user(
            username='head',
            password='testpassword',
            first_name='Robert',
            last_name='Brown'
        )

        self.department_head = Employee.objects.create(
            user=self.head_user,
            department=self.department,
            position='Department Head',
            role='department_head',
            hire_date=timezone.now().date() - timedelta(days=1095)
        )

        # Создаем тестовые данные для статистики
        self.hazard = Hazard.objects.create(
            name='Test Hazard',
            category='Physical'
        )

        self.risk = Risk.objects.create(
            hazard=self.hazard,
            department=self.department,
            level='medium',
            probability=0.5,
            severity=5,
            description='Test Risk',
            evaluated_by=self.head_user
        )

        # Проверка и нарушение
        self.inspection = Inspection.objects.create(
            title='Test Inspection',
            inspection_type='Regular',
            department=self.department,
            start_date=timezone.now() - timedelta(days=30),
            lead_inspector=self.head_user
        )

        self.finding = InspectionFinding.objects.create(
            inspection=self.inspection,
            description='Test Finding',
            severity='Medium',
            status='completed'
        )

        # Создаем уведомление
        self.notification = Notification.objects.create(
            user=self.employee_user,
            title='Test Notification',
            message='This is a test notification',
            notification_type='general',
            is_read=False
        )

        # Инициализируем клиента для тестирования
        self.client = Client()

    def test_dashboard_employee_authorized_access(self):
        """Тест, что авторизованный сотрудник может получить доступ к дашборду"""
        # Логинимся как сотрудник
        login_success = self.client.login(username='employee', password='testpassword')
        self.assertTrue(login_success, "Вход в систему должен быть успешным")

        # Получаем страницу дашборда
        response = self.client.get(reverse('dashboard'))

        # Проверяем, что доступ разрешен
        self.assertEqual(response.status_code, 200, "Авторизованный сотрудник должен иметь доступ к дашборду")

        # Проверяем, что используется правильный шаблон
        self.assertTemplateUsed(response, 'dashboard/dashboard.html')

        # Проверка наличия ключевых элементов в контексте
        self.assertIn('user_role', response.context, "Должна быть указана роль пользователя")
        self.assertIn('notification_count', response.context, "Должно быть указано количество уведомлений")

    def test_dashboard_medical_worker_authorized_access(self):
        """Тест, что авторизованный медицинский работник может получить доступ к дашборду"""
        # Логинимся как медицинский работник
        login_success = self.client.login(username='medical', password='testpassword')
        self.assertTrue(login_success, "Вход в систему должен быть успешным")

        # Получаем страницу дашборда
        response = self.client.get(reverse('dashboard'))

        # Проверяем, что доступ разрешен
        self.assertEqual(response.status_code, 200,
                         "Авторизованный медицинский работник должен иметь доступ к дашборду")

        # Проверяем наличие ключевых элементов в контексте
        self.assertIn('user_role', response.context, "Должна быть указана роль пользователя")
        self.assertIn('notification_count', response.context, "Должно быть указано количество уведомлений")

        # Проверяем, что пользователь существует и имеет правильную роль в модели
        db_employee = Employee.objects.get(user=self.medical_user)
        self.assertEqual(db_employee.role, 'medical_worker', "В базе данных должна быть установлена правильная роль")

    def test_dashboard_department_head_authorized_access(self):
        """Тест, что авторизованный руководитель подразделения может получить доступ к дашборду"""
        # Логинимся как руководитель подразделения
        login_success = self.client.login(username='head', password='testpassword')
        self.assertTrue(login_success, "Вход в систему должен быть успешным")

        # Получаем страницу дашборда
        response = self.client.get(reverse('dashboard'))

        # Проверяем, что доступ разрешен
        self.assertEqual(response.status_code, 200, "Авторизованный руководитель должен иметь доступ к дашборду")

        # Проверяем наличие ключевых элементов в контексте
        self.assertIn('user_role', response.context, "Должна быть указана роль пользователя")
        self.assertIn('notification_count', response.context, "Должно быть указано количество уведомлений")

        # Проверяем, что пользователь существует и имеет правильную роль в модели
        db_employee = Employee.objects.get(user=self.head_user)
        self.assertEqual(db_employee.role, 'department_head', "В базе данных должна быть установлена правильная роль")

    def test_dashboard_requires_authentication(self):
        """Тест, что дашборд требует аутентификации"""
        # Выходим из системы
        self.client.logout()

        # Пытаемся получить дашборд
        response = self.client.get(reverse('dashboard'))

        # Проверяем, что неавторизованный доступ вызывает редирект
        self.assertEqual(response.status_code, 302, "Неавторизованный доступ должен вызывать редирект")

        # Проверяем, что URL содержит параметр next с указанием на дашборд
        self.assertIn('next=', response.url, "URL должен содержать параметр next")
        self.assertIn('/dashboard/', response.url, "URL должен направлять на дашборд после логина")

    def test_notification_count_accuracy(self):
        """Тест точности счетчика уведомлений"""
        # Логинимся как сотрудник
        self.client.login(username='employee', password='testpassword')

        # Получаем страницу дашборда
        response = self.client.get(reverse('dashboard'))

        # Проверяем, что количество уведомлений соответствует созданному в setUp
        expected_count = Notification.objects.filter(user=self.employee_user, is_read=False).count()
        self.assertEqual(response.context['notification_count'], expected_count,
                         "Счетчик уведомлений должен показывать правильное число")

    def test_dashboard_contains_safety_statistics(self):
        """Тест наличия статистики безопасности на дашборде"""
        # Логинимся как сотрудник
        self.client.login(username='employee', password='testpassword')

        # Получаем страницу дашборда
        response = self.client.get(reverse('dashboard'))

        # Проверяем наличие ключевых показателей безопасности
        self.assertIn('identified_risks_count', response.context,
                      "Должно отображаться количество выявленных рисков")
        self.assertIn('compliance_percentage', response.context,
                      "Должен отображаться процент соответствия нормам")

~19) utils.py;~

import io
from datetime import timezone, timedelta

import xlsxwriter
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph
from reportlab.lib.styles import getSampleStyleSheet
from django.http import HttpResponse


def generate_excel_report(data, title="Отчет"):
    """Генерирует отчет в формате Excel"""
    output = io.BytesIO()

    # Создаем новую рабочую книгу Excel и добавляем лист
    workbook = xlsxwriter.Workbook(output)
    worksheet = workbook.add_worksheet("Отчет")

    # Форматирование для заголовков
    header_format = workbook.add_format({
        'bold': True,
        'bg_color': '#FF7A00',
        'color': 'white',
        'align': 'center',
        'valign': 'vcenter',
        'border': 1
    })

    # Форматирование для данных
    data_format = workbook.add_format({
        'border': 1
    })

    # Форматирование для итогов
    total_format = workbook.add_format({
        'bold': True,
        'bg_color': '#F8F8F8',
        'border': 1
    })

    # Пример данных для отчета проверок
    row = 0

    # Добавляем заголовок отчета
    worksheet.merge_range(row, 0, row, 7, title, header_format)
    row += 2

    # Заголовки колонок
    headers = ['Дата', 'Тип проверки', 'Подразделение', 'Инспектор', 'Нарушений', 'Устранено', 'Статус']
    for col, header in enumerate(headers):
        worksheet.write(row, col, header, header_format)

    # Записываем данные
    row += 1
    for inspection in data['inspections']:
        worksheet.write(row, 0, inspection['date'], data_format)
        worksheet.write(row, 1, inspection['type'], data_format)
        worksheet.write(row, 2, inspection['department'], data_format)
        worksheet.write(row, 3, inspection['inspector'], data_format)
        worksheet.write(row, 4, inspection['findings_count'], data_format)
        worksheet.write(row, 5, inspection['resolved_count'], data_format)
        worksheet.write(row, 6, inspection['status'], data_format)
        row += 1

    # Добавляем сводную информацию
    row += 2
    worksheet.merge_range(row, 0, row, 1, "Всего проверок:", total_format)
    worksheet.write(row, 2, data['inspections_count'], total_format)

    row += 1
    worksheet.merge_range(row, 0, row, 1, "Выявлено нарушений:", total_format)
    worksheet.write(row, 2, data['findings_count'], total_format)

    row += 1
    worksheet.merge_range(row, 0, row, 1, "Устранено нарушений:", total_format)
    worksheet.write(row, 2, f"{data['resolved_findings_percentage']}%", total_format)

    # Автоматически подгоняем ширину колонок
    for col_num, value in enumerate(headers):
        max_len = max(len(str(value)) + 2, 10)
        worksheet.set_column(col_num, col_num, max_len)

    workbook.close()

    # Возвращаем файл Excel
    output.seek(0)
    return output


def get_medical_exam_status(next_exam_date, warning_days=5):
    """
    Определяет статус медицинского осмотра на основе даты следующего осмотра.

    Args:
        next_exam_date: Дата следующего медосмотра
        warning_days: За сколько дней начинать предупреждать

    Returns:
        Строка: 'overdue', 'warning', 'normal' или 'none' если дата не установлена
    """
    if not next_exam_date:
        return 'none'

    current_date = timezone.now().date()
    warning_date = current_date + timedelta(days=warning_days)

    if next_exam_date < current_date:
        return 'overdue'  # Просрочено
    elif next_exam_date <= warning_date:
        return 'warning'  # Предупреждение
    else:
        return 'normal'  # В норме


def send_medical_exam_notification(employee, created_by=None):
    """
    Отправляет уведомление сотруднику о необходимости пройти медосмотр

    Args:
        employee: Объект Employee, которому отправляется уведомление
        created_by: Объект User, создавший уведомление (опционально)

    Returns:
        Объект созданного уведомления
    """
    from .models import Notification

    notification = Notification.objects.create(
        user=employee.user,
        title='Необходимо пройти медицинский осмотр',
        message=f'Вам необходимо пройти медицинский осмотр. Пожалуйста, обратитесь в медицинский отдел для согласования даты.',
        notification_type='medical',
        related_entity_type='employee',
        related_entity_id=employee.id,
        is_read=False
    )

    return notification


def generate_pdf_report(data, title="Отчет"):
    """Генерирует отчет в формате PDF"""
    buffer = io.BytesIO()

    # Создаем PDF документ
    doc = SimpleDocTemplate(buffer, pagesize=A4)
    elements = []

    # Добавляем стили
    styles = getSampleStyleSheet()
    title_style = styles['Heading1']
    title_style.alignment = 1  # По центру

    # Добавляем заголовок
    elements.append(Paragraph(title, title_style))
    elements.append(Paragraph(f"Период: {data['period']}", styles['Normal']))
    elements.append(Paragraph(f"Дата формирования: {data['report_date']}", styles['Normal']))
    elements.append(Paragraph(" ", styles['Normal']))  # Пустой отступ

    # Добавляем сводную информацию
    summary_data = [
        ["Всего проверок", str(data['inspections_count'])],
        ["Выявлено нарушений", str(data['findings_count'])],
        ["Устранено нарушений", f"{data['resolved_findings_percentage']}%"]
    ]

    summary_table = Table(summary_data, colWidths=[300, 150])
    summary_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 12),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ('BACKGROUND', (1, 0), (1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    elements.append(summary_table)
    elements.append(Paragraph(" ", styles['Normal']))  # Пустой отступ

    # Данные для таблицы проверок
    table_data = [['Дата', 'Тип проверки', 'Подразделение', 'Нарушений', 'Устранено', 'Статус']]

    for inspection in data['inspections']:
        table_data.append([
            inspection['date'],
            inspection['type'],
            inspection['department'],
            str(inspection['findings_count']),
            str(inspection['resolved_count']),
            inspection['status']
        ])

    # Создаем таблицу и стилизуем ее
    table = Table(table_data, repeatRows=1)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.orange),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))

    elements.append(table)

    doc.build(elements)

    buffer.seek(0)
    return buffer

~20) views.py;~

import json
from datetime import timedelta, datetime

import psycopg2
from django.contrib.auth import authenticate, login, logout, user_logged_in, user_logged_out, update_session_auth_hash
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth.models import User
from django.db.models.functions import TruncYear, TruncMonth
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.http import JsonResponse, HttpResponse
from django.db.models import Q, Count
from django.utils import timezone
from django.core.paginator import Paginator
from django.utils.timezone import now
from prometheus_client import generate_latest

from core.customlogger import database_size_gauge
from .decorators import role_required
from .models import (
    Employee, Department, PPEItem, PPERequest, PPEIssuance,
    Document, InstructionType, Instruction, InstructionParticipant,
    Equipment, EquipmentMaintenance, Hazard, Risk, RiskMitigationMeasure,
    Inspection, InspectionFinding, Incident,
    MedicalExamination, Notification, UserLog, IncidentVictim, EvacuationNotification, TestResult, InstructionTest,
    InstructionMaterial, TestAnswerSubmission, TestAnswer
)
from .forms import (
    PPERequestForm, InstructionForm, DocumentForm,
    EquipmentForm, RiskForm, InspectionForm, SafetyTaskForm, ProfileForm, EmployeeForm, EquipmentMaintenanceForm,
    MedicalExaminationForm, InspectionFindingForm, RiskMitigationMeasureForm, TestSubmissionForm,
    InstructionMaterialForm, InstructionTestForm, TestQuestionForm, TestAnswerFormSet
)
from .signals import create_employee_if_missing
from .utils import generate_pdf_report, generate_excel_report


@login_required
def dashboard(request):
    """Главная страница (дашборд) с учетом роли пользователя"""

    # Инициализируем employee как None
    employee = None
    user_role = 'employee'  # По умолчанию

    # Пробуем получить роль пользователя
    try:
        employee = request.user.employee
        user_role = employee.role
    except:
        # Если не получилось - используем значения по умолчанию
        pass

    # Статистика безопасности
    last_incident = Incident.objects.order_by('-incident_date').first()
    if last_incident:
        incident_free_days = (timezone.now().date() - last_incident.incident_date.date()).days
    else:
        incident_free_days = 365  # Если инцидентов нет, показываем 365 дней

    identified_risks_count = Risk.objects.count()

    total_findings = InspectionFinding.objects.count()
    resolved_findings = InspectionFinding.objects.filter(status='completed').count()
    compliance_percentage = 100 if total_findings == 0 else int((resolved_findings / total_findings) * 100)

    # Базовый контекст для всех ролей
    context = {
        'user_role': user_role,
        'incident_free_days': incident_free_days,
        'identified_risks_count': identified_risks_count,
        'compliance_percentage': compliance_percentage,
        'employee': employee,  # Передаем employee в контекст, даже если это None
    }

    # Текущая дата и важные временные точки для медицинских осмотров
    current_date = timezone.now().date()
    warning_date = current_date + timedelta(days=5)
    next_month = current_date + timedelta(days=30)

    # Дополнительный контекст для медицинского работника
    if user_role == 'medical_worker':
        # Сотрудники с просроченными медосмотрами
        overdue_employees = Employee.objects.filter(
            next_medical_exam_date__lt=current_date
        ).select_related('user', 'department').order_by('next_medical_exam_date')[:5]

        # Сотрудники с приближающимися медосмотрами (в течение 5 дней)
        upcoming_employees = Employee.objects.filter(
            next_medical_exam_date__gte=current_date,
            next_medical_exam_date__lte=warning_date
        ).select_related('user', 'department').order_by('next_medical_exam_date')[:5]

        # Сотрудники с медосмотрами в ближайший месяц
        monthly_employees = Employee.objects.filter(
            next_medical_exam_date__gt=warning_date,
            next_medical_exam_date__lte=next_month
        ).select_related('user', 'department').order_by('next_medical_exam_date')[:10]

        # Последние проведенные медосмотры
        recent_exams = MedicalExamination.objects.select_related(
            'employee', 'employee__user', 'employee__department'
        ).order_by('-exam_date')[:5]

        # Статистика по медосмотрам
        total_employees = Employee.objects.count()
        overdue_count = Employee.objects.filter(next_medical_exam_date__lt=current_date).count()
        upcoming_count = Employee.objects.filter(
            next_medical_exam_date__gte=current_date,
            next_medical_exam_date__lte=warning_date
        ).count()
        monthly_count = Employee.objects.filter(
            next_medical_exam_date__gt=warning_date,
            next_medical_exam_date__lte=next_month
        ).count()

        # Статистика по подразделениям
        department_stats = []
        departments = Department.objects.all()

        for dept in departments:
            dept_employees = Employee.objects.filter(department=dept).count()
            if dept_employees > 0:
                overdue_dept = Employee.objects.filter(
                    department=dept,
                    next_medical_exam_date__lt=current_date
                ).count()

                compliance_percent = 100
                if dept_employees > 0:
                    compliance_percent = 100 - int((overdue_dept / dept_employees) * 100)

                department_stats.append({
                    'name': dept.name,
                    'total': dept_employees,
                    'overdue': overdue_dept,
                    'compliance': compliance_percent
                })

        # Сортируем подразделения по соответствию (от худшего к лучшему)
        department_stats.sort(key=lambda x: x['compliance'])

        # Медицинские осмотры по типам
        exam_types = MedicalExamination.objects.values('exam_type').annotate(
            count=Count('id')
        ).order_by('-count')[:5]

        # Обновляем контекст данными для медицинского работника
        context.update({
            'overdue_employees': overdue_employees,
            'upcoming_employees': upcoming_employees,
            'monthly_employees': monthly_employees,
            'recent_exams': recent_exams,
            'total_employees': total_employees,
            'overdue_count': overdue_count,
            'upcoming_count': upcoming_count,
            'monthly_count': monthly_count,
            'department_stats': department_stats,
            'exam_types': exam_types,
            'current_date': current_date,
            'warning_date': warning_date,
            'next_month': next_month
        })

    elif user_role == 'department_head':
        # Проверяем наличие employee и department
        if employee and employee.department:
            department = employee.department

            # Ближайшие инструктажи для подразделения
            upcoming_instructions = Instruction.objects.filter(
                department=department,
                next_instruction_date__gte=timezone.now()
            ).order_by('next_instruction_date')[:5]

            # Критические риски для подразделения
            critical_risks = Risk.objects.filter(
                department=department,
                level__in=['high', 'critical']
            ).order_by('-evaluation_date')[:5]

            # Задачи СИЗ для сотрудников подразделения
            ppe_tasks = PPERequest.objects.filter(
                employee__department=department
            ).select_related('employee', 'employee__user').order_by('-request_date')[:6]

            # Проверки для подразделения
            recent_inspections = Inspection.objects.filter(
                department=department
            ).select_related('lead_inspector').order_by('-start_date')[:5]

            # Сотрудники подразделения с просроченными медосмотрами
            employees_with_overdue_exams = Employee.objects.filter(
                department=department,
                next_medical_exam_date__lt=timezone.now().date()
            ).select_related('user')[:5]

            context.update({
                'upcoming_instructions': upcoming_instructions,
                'critical_risks': critical_risks,
                'ppe_tasks': ppe_tasks,
                'recent_inspections': recent_inspections,
                'employees_with_overdue_exams': employees_with_overdue_exams,
            })
        else:
            # Если department отсутствует, используем пустые списки
            context.update({
                'upcoming_instructions': [],
                'critical_risks': [],
                'ppe_tasks': [],
                'recent_inspections': [],
                'employees_with_overdue_exams': [],
            })

    elif user_role == 'employee':
        # Проверяем наличие employee
        if employee:
            # Инструктажи сотрудника
            instruction_participations = InstructionParticipant.objects.filter(
                employee=employee
            ).select_related('instruction', 'instruction__instruction_type').order_by('-instruction__instruction_date')[
                                         :5]

            # СИЗ сотрудника
            ppe_issuances = PPEIssuance.objects.filter(
                employee=employee,
                actual_return_date__isnull=True  # Еще не возвращенные
            ).select_related('ppe_item').order_by('-issue_date')

            # Медосмотры сотрудника
            medical_exams = MedicalExamination.objects.filter(
                employee=employee
            ).order_by('-exam_date')[:3]

            # Если у сотрудника есть подразделение, то добавляем риски подразделения
            if employee.department:
                # Риски для подразделения сотрудника
                department_risks = Risk.objects.filter(
                    department=employee.department
                ).order_by('-evaluation_date')[:5]

                context.update({
                    'department_risks': department_risks,
                })

            context.update({
                'instruction_participations': instruction_participations,
                'ppe_issuances': ppe_issuances,
                'medical_exams': medical_exams,
            })
        else:
            # Если employee отсутствует, используем пустые списки
            context.update({
                'instruction_participations': [],
                'ppe_issuances': [],
                'medical_exams': [],
                'department_risks': [],
            })

    # Добавляем обработку других ролей по аналогии...

    # Количество непрочитанных уведомлений - для всех ролей
    notification_count = Notification.objects.filter(user=request.user, is_read=False).count()
    context['notification_count'] = notification_count

    return render(request, 'dashboard/dashboard.html', context)
# Поиск
@login_required
def search(request):
    query = request.GET.get('q', '')

    if not query:
        return render(request, 'search_results.html', {'query': query})

    # Поиск по разным моделям
    documents = Document.objects.filter(
        Q(title__icontains=query) | Q(description__icontains=query)
    )[:10]

    ppe_requests = PPERequest.objects.filter(
        Q(notes__icontains=query)
    )[:10]

    instructions = Instruction.objects.filter(
        Q(notes__icontains=query) | Q(location__icontains=query)
    )[:10]

    risks = Risk.objects.filter(
        Q(description__icontains=query) | Q(location__icontains=query)
    )[:10]

    inspections = Inspection.objects.filter(
        Q(title__icontains=query) | Q(description__icontains=query)
    )[:10]

    employees = Employee.objects.filter(
        Q(user__first_name__icontains=query) |
        Q(user__last_name__icontains=query) |
        Q(position__icontains=query)
    )[:10]

    equipment = Equipment.objects.filter(
        Q(name__icontains=query) |
        Q(model__icontains=query) |
        Q(serial_number__icontains=query)
    )[:10]

    context = {
        'query': query,
        'documents': documents,
        'ppe_requests': ppe_requests,
        'instructions': instructions,
        'risks': risks,
        'inspections': inspections,
        'employees': employees,
        'equipment': equipment,
    }
    return render(request, 'search_results.html', context)


# Профиль пользователя
@login_required
def profile(request):
    if request.method == 'POST':
        form = ProfileForm(request.POST, request.FILES, instance=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, 'Профиль успешно обновлен.')
            return redirect('profile')
    else:
        form = ProfileForm(instance=request.user)

    context = {
        'form': form
    }
    return render(request, 'profile.html', context)


# Настройки
@login_required
def settings(request):
    """Страница настроек системы"""

    if request.method == 'POST':
        settings_type = request.POST.get('settings_type', '')

        if settings_type == 'system':
            # Обработка системных настроек
            company_name = request.POST.get('company_name')
            admin_email = request.POST.get('admin_email')
            items_per_page = request.POST.get('items_per_page')

            # Здесь можно добавить логику сохранения настроек

            messages.success(request, 'Системные настройки успешно обновлены.')
            return redirect('settings')

        elif settings_type == 'security':
            # Обработка настроек безопасности
            current_password = request.POST.get('current_password')
            new_password = request.POST.get('new_password')
            confirm_password = request.POST.get('confirm_password')

            # Проверка текущего пароля
            user = request.user
            if not user.check_password(current_password):
                messages.error(request, 'Текущий пароль указан неверно.')
                return redirect('settings')

            # Проверка нового пароля
            if new_password != confirm_password:
                messages.error(request, 'Новый пароль и подтверждение не совпадают.')
                return redirect('settings')

            # Установка нового пароля
            user.set_password(new_password)
            user.save()

            # Обновление сессии, чтобы пользователь не вылетел
            update_session_auth_hash(request, user)

            messages.success(request, 'Пароль успешно изменен.')
            return redirect('settings')

    # Загрузка данных для справочников
    try:
        departments = Department.objects.all()
        ppe_items = PPEItem.objects.all()
        instruction_types = InstructionType.objects.all()
        hazards = Hazard.objects.all()
    except:
        departments = []
        ppe_items = []
        instruction_types = []
        hazards = []

    context = {
        'departments': departments,
        'ppe_items': ppe_items,
        'instruction_types': instruction_types,
        'hazards': hazards
    }

    return render(request, 'settings.html', context)


# Задачи СИЗ
@login_required
def ppe_list(request):
    ppe_requests = PPERequest.objects.select_related(
        'employee', 'employee__user', 'ppe_item'
    ).order_by('-request_date')

    # Фильтрация
    status_filter = request.GET.get('status')
    if status_filter:
        ppe_requests = ppe_requests.filter(status=status_filter)

    # Пагинация
    paginator = Paginator(ppe_requests, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'status_filter': status_filter,
    }
    return render(request, 'ppe/ppe_list.html', context)


@login_required
def ppe_detail(request, pk):
    ppe_request = get_object_or_404(PPERequest, pk=pk)

    # История выдачи СИЗ для этого сотрудника
    issuance_history = PPEIssuance.objects.filter(
        employee=ppe_request.employee
    ).order_by('-issue_date')

    context = {
        'ppe_request': ppe_request,
        'issuance_history': issuance_history,
    }
    return render(request, 'ppe/ppe_detail.html', context)


@login_required
def ppe_create(request):
    if request.method == 'POST':
        form = PPERequestForm(request.POST)
        if form.is_valid():
            ppe_request = form.save(commit=False)
            ppe_request.save()
            messages.success(request, 'Заявка на СИЗ успешно создана.')
            return redirect('ppe_list')
    else:
        form = PPERequestForm()

    context = {
        'form': form,
        'title': 'Создание заявки на СИЗ'
    }
    return render(request, 'ppe/ppe_form.html', context)


@login_required
@role_required(['admin', 'safety_specialist', 'department_head'])
def ppe_update(request, pk):
    ppe_request = get_object_or_404(PPERequest, pk=pk)

    if request.method == 'POST':
        form = PPERequestForm(request.POST, instance=ppe_request)
        if form.is_valid():
            form.save()
            messages.success(request, 'Заявка на СИЗ успешно обновлена.')
            return redirect('ppe_detail', pk=ppe_request.pk)
    else:
        form = PPERequestForm(instance=ppe_request)

    context = {
        'form': form,
        'title': 'Редактирование заявки на СИЗ'
    }
    return render(request, 'ppe/ppe_form.html', context)


@login_required
@role_required(['admin', 'safety_specialist', 'department_head'])
def ppe_delete(request, pk):
    ppe_request = get_object_or_404(PPERequest, pk=pk)

    if request.method == 'POST':
        ppe_request.delete()
        messages.success(request, 'Заявка на СИЗ успешно удалена.')
        return redirect('ppe_list')

    context = {
        'ppe_request': ppe_request
    }
    return render(request, 'ppe/ppe_confirm_delete.html', context)


# Инструктажи
@login_required
def instruction_list(request):
    # Получаем все инструктажи с необходимыми связями
    instructions = Instruction.objects.select_related(
        'instruction_type', 'instructor', 'department'
    ).all()

    # Добавляем количество участников к каждому инструктажу
    instructions = instructions.annotate(participants_count=Count('participants'))

    # Фильтрация по подразделению
    department_filter = request.GET.get('department')
    if department_filter:
        instructions = instructions.filter(department_id=department_filter)

    # Фильтрация по типу инструктажа
    type_filter = request.GET.get('type')
    if type_filter:
        instructions = instructions.filter(instruction_type_id=type_filter)

    # Список всех подразделений для фильтра
    departments = Department.objects.all()

    # Список всех типов инструктажей для фильтра
    instruction_types = InstructionType.objects.all()

    # Пагинация
    paginator = Paginator(instructions.order_by('-instruction_date'), 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Текущая дата
    current_date = timezone.now().date()

    # Данные для графика по типам инструктажей
    instruction_types_chart_data = Instruction.objects.values(
        'instruction_type__name'
    ).annotate(
        count=Count('id')
    ).order_by('-count')

    instruction_types_labels = [item['instruction_type__name'] for item in instruction_types_chart_data]
    instruction_types_counts = [item['count'] for item in instruction_types_chart_data]

    # Данные для графика по месяцам
    six_months_ago = timezone.now().date() - timedelta(days=180)
    instruction_months_chart_data = Instruction.objects.filter(
        instruction_date__date__gte=six_months_ago
    ).annotate(
        month=TruncMonth('instruction_date')
    ).values('month').annotate(
        count=Count('id')
    ).order_by('month')

    instruction_months_labels = [item['month'].strftime('%b %Y') for item in instruction_months_chart_data]
    instruction_months_counts = [item['count'] for item in instruction_months_chart_data]

    context = {
        'page_obj': page_obj,
        'departments': departments,
        'instruction_types': instruction_types,
        'department_filter': department_filter,
        'type_filter': type_filter,
        'current_date': current_date,
        'instruction_types_labels': json.dumps(instruction_types_labels),
        'instruction_types_counts': json.dumps(instruction_types_counts),
        'instruction_months_labels': json.dumps(instruction_months_labels),
        'instruction_months_counts': json.dumps(instruction_months_counts),
    }
    return render(request, 'instructions/instruction_list.html', context)


@login_required
def instruction_detail(request, pk):
    instruction = get_object_or_404(Instruction, pk=pk)

    # Участники инструктажа
    participants = InstructionParticipant.objects.filter(
        instruction=instruction
    ).select_related('employee', 'employee__user')

    context = {
        'instruction': instruction,
        'participants': participants,
    }
    return render(request, 'instructions/instruction_detail.html', context)


@login_required
def instruction_create(request):
    if request.method == 'POST':
        form = InstructionForm(request.POST)
        if form.is_valid():
            instruction = form.save(commit=False)
            instruction.instructor = request.user
            instruction.save()

            # Обработка выбранных участников
            participant_ids = request.POST.getlist('participants')
            for employee_id in participant_ids:
                InstructionParticipant.objects.create(
                    instruction=instruction,
                    employee_id=employee_id,
                    status='attended'
                )

            messages.success(request, 'Инструктаж успешно создан.')
            return redirect('instruction_list')
    else:
        form = InstructionForm()

    # Список сотрудников для выбора участников
    employees = Employee.objects.select_related('user', 'department').all()

    context = {
        'form': form,
        'employees': employees,
        'title': 'Проведение инструктажа'
    }
    return render(request, 'instructions/instruction_form.html', context)


@login_required
def instruction_update(request, pk):
    instruction = get_object_or_404(Instruction, pk=pk)

    if request.method == 'POST':
        form = InstructionForm(request.POST, instance=instruction)
        if form.is_valid():
            form.save()

            # Получение текущих участников перед удалением
            existing_participants = list(InstructionParticipant.objects.filter(
                instruction=instruction
            ).values_list('employee_id', flat=True))

            # Обновление участников
            InstructionParticipant.objects.filter(instruction=instruction).delete()
            participant_ids = request.POST.getlist('participants')

            # Находим новых участников (тех, которых не было раньше)
            new_participant_ids = [int(id) for id in participant_ids if int(id) not in existing_participants]

            # Создаем объекты участников
            for employee_id in participant_ids:
                InstructionParticipant.objects.create(
                    instruction=instruction,
                    employee_id=employee_id,
                    status='attended'
                )

            # Отправляем уведомления только новым участникам
            if new_participant_ids:
                new_employees = Employee.objects.filter(id__in=new_participant_ids)
                for employee in new_employees:
                    Notification.objects.create(
                        user=employee.user,
                        title=f'Назначен инструктаж: {instruction.instruction_type.name}',
                        message=f'Вам назначен инструктаж "{instruction.instruction_type.name}". Дата проведения: {instruction.instruction_date.strftime("%d.%m.%Y %H:%M")}.',
                        notification_type='instruction_assigned',
                        related_entity_type='instruction',
                        related_entity_id=instruction.id,
                        is_read=False
                    )

            messages.success(request, 'Инструктаж успешно обновлен.')
            return redirect('instruction_detail', pk=instruction.pk)
    else:
        form = InstructionForm(instance=instruction)

    # Список сотрудников для выбора участников
    employees = Employee.objects.select_related('user', 'department').all()

    # Текущие участники
    current_participants = InstructionParticipant.objects.filter(
        instruction=instruction
    ).values_list('employee_id', flat=True)

    context = {
        'form': form,
        'employees': employees,
        'current_participants': current_participants,
        'title': 'Редактирование инструктажа'
    }
    return render(request, 'instructions/instruction_form.html', context)

@login_required
def instruction_delete(request, pk):
    instruction = get_object_or_404(Instruction, pk=pk)

    if request.method == 'POST':
        instruction.delete()
        messages.success(request, 'Инструктаж успешно удален.')
        return redirect('instruction_list')

    context = {
        'instruction': instruction
    }
    return render(request, 'instructions/instruction_confirm_delete.html', context)


# Нормативные документы
@login_required
def document_list(request):
    # Получаем все документы
    documents = Document.objects.all()

    # Фильтрация по типу документа
    document_type = request.GET.get('type')
    if document_type:
        documents = documents.filter(document_type=document_type)

    # Фильтрация по статусу
    is_active_filter = request.GET.get('is_active')
    if is_active_filter is not None:
        is_active = is_active_filter == '1'
        documents = documents.filter(is_active=is_active)

    # Получаем список всех типов документов для фильтра
    document_types = Document.objects.values_list('document_type', flat=True).distinct()

    # Пагинация
    paginator = Paginator(documents.order_by('-updated_at'), 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Текущая дата
    current_date = timezone.now().date()

    # Недавно обновленные документы (для бокового списка)
    recent_documents = Document.objects.order_by('-updated_at')[:5]

    # Данные для графика по типам документов
    document_types_chart_data = Document.objects.values('document_type').annotate(
        count=Count('id')
    ).order_by('-count')

    document_types_labels = [item['document_type'] for item in document_types_chart_data]
    document_types_counts = [item['count'] for item in document_types_chart_data]

    # Данные для графика по годам публикации
    document_years_chart_data = Document.objects.exclude(publish_date=None).annotate(
        year=TruncYear('publish_date')
    ).values('year').annotate(
        count=Count('id')
    ).order_by('year')

    document_years_labels = [item['year'].strftime('%Y') for item in document_years_chart_data]
    document_years_counts = [item['count'] for item in document_years_chart_data]

    context = {
        'page_obj': page_obj,
        'document_types': document_types,
        'document_type': document_type,
        'is_active_filter': is_active_filter,
        'current_date': current_date,
        'recent_documents': recent_documents,
        'document_types_labels': json.dumps(document_types_labels),
        'document_types_counts': json.dumps(document_types_counts),
        'document_years_labels': json.dumps(document_years_labels),
        'document_years_counts': json.dumps(document_years_counts),
    }
    return render(request, 'documents/document_list.html', context)

@login_required
def document_detail(request, pk):
    document = get_object_or_404(Document, pk=pk)

    context = {
        'document': document
    }
    return render(request, 'documents/document_detail.html', context)


@login_required
@role_required(['admin', 'safety_specialist', 'department_head'])
def document_create(request):
    if request.method == 'POST':
        form = DocumentForm(request.POST, request.FILES)
        if form.is_valid():
            document = form.save()
            messages.success(request, 'Документ успешно создан.')
            return redirect('document_list')
    else:
        form = DocumentForm()

    context = {
        'form': form,
        'title': 'Добавление документа'
    }
    return render(request, 'documents/document_form.html', context)


@login_required
@role_required(['admin', 'safety_specialist', 'department_head'])
def document_update(request, pk):
    document = get_object_or_404(Document, pk=pk)

    if request.method == 'POST':
        form = DocumentForm(request.POST, request.FILES, instance=document)
        if form.is_valid():
            form.save()
            messages.success(request, 'Документ успешно обновлен.')
            return redirect('document_detail', pk=document.pk)
    else:
        form = DocumentForm(instance=document)

    context = {
        'form': form,
        'document': document,
        'title': 'Редактирование документа'
    }
    return render(request, 'documents/document_form.html', context)


@login_required
@role_required(['admin', 'safety_specialist', 'department_head'])
def document_delete(request, pk):
    document = get_object_or_404(Document, pk=pk)

    if request.method == 'POST':
        document.delete()
        messages.success(request, 'Документ успешно удален.')
        return redirect('document_list')

    context = {
        'document': document
    }
    return render(request, 'documents/document_confirm_delete.html', context)


# Риски и опасности
@login_required
@role_required(['admin', 'safety_specialist', 'department_head'])
def risk_list(request):
    risks = Risk.objects.select_related('hazard', 'department').all()

    # Фильтрация
    level_filter = request.GET.get('level')
    if level_filter:
        risks = risks.filter(level=level_filter)

    # Пагинация
    paginator = Paginator(risks.order_by('-evaluation_date'), 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Данные для графика по уровням рисков
    risk_levels_chart_data = Risk.objects.values('level').annotate(
        count=Count('id')
    ).order_by('level')

    risk_levels_labels = [
        'Низкий' if item['level'] == 'low' else
        'Средний' if item['level'] == 'medium' else
        'Высокий' if item['level'] == 'high' else
        'Критический' for item in risk_levels_chart_data
    ]
    risk_levels_counts = [item['count'] for item in risk_levels_chart_data]

    # Данные для графика по подразделениям
    risk_departments_chart_data = Risk.objects.values(
        'department__name'
    ).annotate(
        count=Count('id')
    ).order_by('-count')[:5]  # Топ-5 подразделений по количеству рисков

    risk_departments_labels = [item['department__name'] for item in risk_departments_chart_data]
    risk_departments_counts = [item['count'] for item in risk_departments_chart_data]

    context = {
        'page_obj': page_obj,
        'level_filter': level_filter,
        'risk_levels_labels': json.dumps(risk_levels_labels),
        'risk_levels_counts': json.dumps(risk_levels_counts),
        'risk_departments_labels': json.dumps(risk_departments_labels),
        'risk_departments_counts': json.dumps(risk_departments_counts),
    }
    return render(request, 'risks/risk_list.html', context)


@login_required
@role_required(['admin', 'safety_specialist', 'department_head'])
def risk_detail(request, pk):
    risk = get_object_or_404(Risk, pk=pk)

    # Мероприятия по снижению риска
    mitigation_measures = RiskMitigationMeasure.objects.filter(risk=risk).order_by('-created_at')

    context = {
        'risk': risk,
        'mitigation_measures': mitigation_measures,
    }
    return render(request, 'risks/risk_detail.html', context)


@login_required
@role_required(['admin', 'safety_specialist'])
def risk_create(request):
    if request.method == 'POST':
        form = RiskForm(request.POST)
        if form.is_valid():
            risk = form.save(commit=False)
            risk.evaluated_by = request.user
            risk.save()
            messages.success(request, 'Риск успешно добавлен.')
            return redirect('risk_list')
    else:
        form = RiskForm()

    context = {
        'form': form,
        'title': 'Добавление риска'
    }
    return render(request, 'risks/risk_form.html', context)


@login_required
@role_required(['admin', 'safety_specialist'])
def risk_update(request, pk):
    risk = get_object_or_404(Risk, pk=pk)

    if request.method == 'POST':
        form = RiskForm(request.POST, instance=risk)
        if form.is_valid():
            form.save()
            messages.success(request, 'Риск успешно обновлен.')
            return redirect('risk_detail', pk=risk.pk)
    else:
        form = RiskForm(instance=risk)

    context = {
        'form': form,
        'risk': risk,
        'title': 'Редактирование риска'
    }
    return render(request, 'risks/risk_form.html', context)


@login_required
@role_required(['admin', 'safety_specialist'])
def risk_delete(request, pk):
    risk = get_object_or_404(Risk, pk=pk)

    if request.method == 'POST':
        risk.delete()
        messages.success(request, 'Риск успешно удален.')
        return redirect('risk_list')

    context = {
        'risk': risk
    }
    return render(request, 'risks/risk_confirm_delete.html', context)


@login_required
def risk_assessment(request):
    # Логика для страницы оценки рисков
    hazards = Hazard.objects.all()
    departments = Department.objects.all()

    context = {
        'hazards': hazards,
        'departments': departments,
    }
    return render(request, 'risks/risk_assessment.html', context)


# Проверки
@login_required
def inspection_list(request):
    inspections = Inspection.objects.select_related('department', 'lead_inspector').all()

    # Добавляем количество нарушений к каждой проверке
    inspections = inspections.annotate(
        findings_count=Count('findings'),
        resolved_findings_count=Count('findings', filter=Q(findings__status='completed')),
        overdue_findings_count=Count(
            'findings',
            filter=Q(findings__status__in=['new', 'in_progress']) & Q(findings__deadline__lt=timezone.now())
        )
    )

    # Фильтрация
    status_filter = request.GET.get('status')
    if status_filter:
        inspections = inspections.filter(status=status_filter)

    # Пагинация
    paginator = Paginator(inspections.order_by('-start_date'), 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Данные для графика по статусам проверок
    inspection_status_chart_data = Inspection.objects.values('status').annotate(
        count=Count('id')
    ).order_by('status')

    inspection_status_labels = [
        'Новая' if item['status'] == 'new' else
        'В процессе' if item['status'] == 'in_progress' else
        'Завершена' if item['status'] == 'completed' else
        'Отменена' for item in inspection_status_chart_data
    ]
    inspection_status_counts = [item['count'] for item in inspection_status_chart_data]

    # Данные для графика по типам проверок
    inspection_types_chart_data = Inspection.objects.values('inspection_type').annotate(
        count=Count('id')
    ).order_by('-count')

    inspection_types_labels = [item['inspection_type'] for item in inspection_types_chart_data]
    inspection_types_counts = [item['count'] for item in inspection_types_chart_data]

    context = {
        'page_obj': page_obj,
        'status_filter': status_filter,
        'inspection_status_labels': json.dumps(inspection_status_labels),
        'inspection_status_counts': json.dumps(inspection_status_counts),
        'inspection_types_labels': json.dumps(inspection_types_labels),
        'inspection_types_counts': json.dumps(inspection_types_counts),
    }
    return render(request, 'inspections/inspection_list.html', context)


@login_required
def inspection_detail(request, pk):
    inspection = get_object_or_404(Inspection, pk=pk)

    # Выявленные нарушения
    findings = InspectionFinding.objects.filter(inspection=inspection).order_by('-created_at')

    context = {
        'inspection': inspection,
        'findings': findings,
    }
    return render(request, 'inspections/inspection_detail.html', context)


@login_required
def inspection_create(request):
    if request.method == 'POST':
        form = InspectionForm(request.POST)
        if form.is_valid():
            inspection = form.save(commit=False)
            inspection.lead_inspector = request.user
            inspection.save()
            messages.success(request, 'Проверка успешно создана.')
            return redirect('inspection_list')
    else:
        form = InspectionForm()

    context = {
        'form': form,
        'title': 'Создание проверки'
    }
    return render(request, 'inspections/inspection_form.html', context)


@login_required
def inspection_update(request, pk):
    inspection = get_object_or_404(Inspection, pk=pk)

    if request.method == 'POST':
        form = InspectionForm(request.POST, instance=inspection)
        if form.is_valid():
            form.save()
            messages.success(request, 'Проверка успешно обновлена.')
            return redirect('inspection_detail', pk=inspection.pk)
    else:
        form = InspectionForm(instance=inspection)

    context = {
        'form': form,
        'inspection': inspection,
        'title': 'Редактирование проверки'
    }
    return render(request, 'inspections/inspection_form.html', context)


@login_required
def inspection_delete(request, pk):
    inspection = get_object_or_404(Inspection, pk=pk)

    if request.method == 'POST':
        inspection.delete()
        messages.success(request, 'Проверка успешно удалена.')
        return redirect('inspection_list')

    context = {
        'inspection': inspection
    }
    return render(request, 'inspections/inspection_confirm_delete.html', context)


@login_required
def inspection_results_report(request, format=None):
    """Отчет по результатам проверок с возможностью выгрузки в Excel или PDF"""
    # Получаем данные для отчета
    inspections = Inspection.objects.select_related('department', 'lead_inspector').all()

    # Фильтрация по дате, если указан период
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')

    if date_from:
        inspections = inspections.filter(start_date__gte=date_from)
    if date_to:
        inspections = inspections.filter(start_date__lte=date_to)

    # Собираем данные для отчета
    inspections_count = inspections.count()
    findings_count = InspectionFinding.objects.filter(inspection__in=inspections).count()
    resolved_findings_count = InspectionFinding.objects.filter(
        inspection__in=inspections,
        status='completed'
    ).count()

    # Считаем процент устраненных нарушений
    if findings_count > 0:
        resolved_findings_percentage = int((resolved_findings_count / findings_count) * 100)
    else:
        resolved_findings_percentage = 100

    # Подготавливаем данные для шаблона и экспорта
    inspection_data = []
    for inspection in inspections:
        findings_in_inspection = InspectionFinding.objects.filter(inspection=inspection)
        findings_count_in_inspection = findings_in_inspection.count()
        resolved_count_in_inspection = findings_in_inspection.filter(status='completed').count()

        inspection_data.append({
            'date': inspection.start_date.strftime('%d.%m.%Y'),
            'type': inspection.inspection_type,
            'department': inspection.department.name if inspection.department else '-',
            'inspector': f"{inspection.lead_inspector.last_name} {inspection.lead_inspector.first_name}" if inspection.lead_inspector else '-',
            'findings_count': findings_count_in_inspection,
            'resolved_count': resolved_count_in_inspection,
            'status': 'Завершена' if inspection.status == 'completed' else
            'В процессе' if inspection.status == 'in_progress' else
            'Новая' if inspection.status == 'new' else 'Отменена'
        })

    # Формируем общие данные для отчета
    report_data = {
        'inspections': inspection_data,
        'inspections_count': inspections_count,
        'findings_count': findings_count,
        'resolved_findings_count': resolved_findings_count,
        'resolved_findings_percentage': resolved_findings_percentage,
        'period': f"{date_from} - {date_to}" if date_from and date_to else "Весь период",
        'report_date': timezone.now().strftime('%d.%m.%Y %H:%M')
    }

    # Если запрос на экспорт, генерируем файл
    if format == 'excel':
        output = generate_excel_report(report_data, "Результаты проверок")
        response = HttpResponse(
            output.getvalue(),
            content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )
        response['Content-Disposition'] = 'attachment; filename=inspection_results.xlsx'
        return response

    elif format == 'pdf':
        output = generate_pdf_report(report_data, "Результаты проверок")
        response = HttpResponse(output.getvalue(), content_type='application/pdf')
        response['Content-Disposition'] = 'attachment; filename=inspection_results.pdf'
        return response

    # Если обычный запрос, отображаем шаблон
    context = {
        'title': 'Результаты проверок',
        'inspections_counts': inspections_count,
        'findings_count': findings_count,
        'resolved_findings_count': resolved_findings_count,
        'resolved_findings_percentage': resolved_findings_percentage,
        'inspections': inspection_data,
        'current_date': timezone.now().date(),
        'date_from': date_from,
        'date_to': date_to
    }

    return render(request, 'reports/inspection_results.html', context)

# Отчеты
@login_required
def report_list(request):
    context = {
        'report_types': [
            {'id': 'safety_metrics', 'name': 'Показатели безопасности'},
            {'id': 'inspection_results', 'name': 'Результаты проверок'},
            {'id': 'ppe_usage', 'name': 'Использование СИЗ'},
            {'id': 'incident_analysis', 'name': 'Анализ происшествий'},
            {'id': 'training_compliance', 'name': 'Соответствие обучения'},
        ]
    }
    return render(request, 'reports/report_list.html', context)


@login_required
def report_generate(request, report_type):
    context = {
        'report_type': report_type
    }

    # Получаем текущую дату для фильтрации данных
    current_date = timezone.now().date()
    year_ago = current_date - timedelta(days=365)
    month_ago = current_date - timedelta(days=30)
    next_month = current_date + timedelta(days=30)

    if report_type == 'safety_metrics':
        # Показатели безопасности
        incidents = Incident.objects.all()
        incidents_count = incidents.count()

        # Последний инцидент для расчета дней без происшествий
        last_incident = incidents.order_by('-incident_date').first()
        if last_incident:
            incident_free_days = (current_date - last_incident.incident_date.date()).days
        else:
            incident_free_days = 365

        # Риски по уровням с процентами и количеством устраненных
        risks_by_level = []
        total_risks = Risk.objects.count()

        for level in ['low', 'medium', 'high', 'critical']:
            risks_count = Risk.objects.filter(level=level).count()
            if total_risks > 0:
                percentage = int((risks_count / total_risks) * 100)
            else:
                percentage = 0

            # Подсчет устраненных рисков по уровню
            # Считаем риск устраненным, если у него есть хотя бы одно завершенное мероприятие
            mitigated_count = Risk.objects.filter(
                level=level,
                mitigation_measures__status='completed'
            ).distinct().count()

            risks_by_level.append({
                'level': level,
                'count': risks_count,
                'percentage': percentage,
                'mitigated': mitigated_count
            })

        # Статистика по нарушениям
        total_findings = InspectionFinding.objects.count()
        resolved_findings = InspectionFinding.objects.filter(status='completed').count()

        if total_findings > 0:
            compliance_percentage = int((resolved_findings / total_findings) * 100)
        else:
            compliance_percentage = 100

        # Разбивка происшествий по месяцам для графика
        months = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
                  'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']

        incidents_by_month = []
        for i in range(6):
            month_date = current_date - timedelta(days=30 * i)
            month_start = month_date.replace(day=1)
            if month_date.month == 12:
                month_end = month_date.replace(year=month_date.year + 1, month=1, day=1) - timedelta(days=1)
            else:
                month_end = month_date.replace(month=month_date.month + 1, day=1) - timedelta(days=1)

            count = Incident.objects.filter(
                incident_date__date__gte=month_start,
                incident_date__date__lte=month_end
            ).count()

            incidents_by_month.append({
                'month': months[month_date.month - 1],
                'count': count
            })

        context.update({
            'title': 'Показатели безопасности',
            'incidents_count': incidents_count,
            'incident_free_days': incident_free_days,
            'risks_by_level': risks_by_level,
            'total_findings': total_findings,
            'resolved_findings': resolved_findings,
            'compliance_percentage': compliance_percentage,
            'incidents_by_month': incidents_by_month,
            'last_incident': last_incident,
            'current_date': current_date
        })

    elif report_type == 'inspection_results':
        # Результаты проверок
        inspections = Inspection.objects.all()
        inspections_count = inspections.count()

        # Нарушения по статусам
        findings = InspectionFinding.objects.all()
        findings_count = findings.count()
        resolved_findings_count = findings.filter(status='completed').count()

        if findings_count > 0:
            findings_resolution_percentage = int((resolved_findings_count / findings_count) * 100)
        else:
            findings_resolution_percentage = 100

        # Статусы проверок для круговой диаграммы
        statuses_data = {
            'new': inspections.filter(status='new').count(),
            'in_progress': inspections.filter(status='in_progress').count(),
            'completed': inspections.filter(status='completed').count(),
            'canceled': inspections.filter(status='canceled').count()
        }

        # Нарушения по подразделениям
        departments = Department.objects.all()
        department_findings = []

        for dept in departments[:5]:  # Ограничим только первыми 5 отделами для наглядности
            found_count = InspectionFinding.objects.filter(
                responsible_department=dept
            ).count()

            resolved_count = InspectionFinding.objects.filter(
                responsible_department=dept,
                status='completed'
            ).count()

            if found_count > 0:
                department_findings.append({
                    'name': dept.name,
                    'found': found_count,
                    'resolved': resolved_count
                })

        # Статистика по типам проверок
        inspection_types = {}
        for inspection in inspections:
            insp_type = inspection.inspection_type
            if insp_type not in inspection_types:
                inspection_types[insp_type] = {
                    'count': 0,
                    'findings': 0,
                    'resolved': 0
                }

            inspection_types[insp_type]['count'] += 1
            findings_in_inspection = InspectionFinding.objects.filter(inspection=inspection)
            inspection_types[insp_type]['findings'] += findings_in_inspection.count()
            inspection_types[insp_type]['resolved'] += findings_in_inspection.filter(status='completed').count()

        inspection_types_data = []
        for insp_type, data in inspection_types.items():
            if data['findings'] > 0:
                resolution_percentage = int((data['resolved'] / data['findings']) * 100)
            else:
                resolution_percentage = 100

            inspection_types_data.append({
                'type': insp_type,
                'count': data['count'],
                'findings': data['findings'],
                'resolved': data['resolved'],
                'percentage': resolution_percentage
            })

        # Последние проверки
        recent_inspections = inspections.select_related('lead_inspector', 'department').order_by('-start_date')[:10]

        # Для каждой проверки подсчитываем количество нарушений и устраненных
        for inspection in recent_inspections:
            findings_in_inspection = InspectionFinding.objects.filter(inspection=inspection)
            inspection.findings_count = findings_in_inspection.count()
            inspection.resolved_findings_count = findings_in_inspection.filter(status='completed').count()

        context.update({
            'title': 'Результаты проверок',
            'inspections_counts': inspections_count,
            'findings_count': findings_count,
            'resolved_findings_count': resolved_findings_count,
            'findings_resolution_percentage': findings_resolution_percentage,
            'statuses_data': statuses_data,
            'department_findings': department_findings,
            'inspection_types_data': inspection_types_data,
            'inspections': recent_inspections,
            'current_date': current_date
        })

    elif report_type == 'ppe_usage':
        # Использование СИЗ
        from django.db.models import Sum

        ppe_items = PPEItem.objects.all()
        ppe_requests = PPERequest.objects.all()
        ppe_requests_count = ppe_requests.count()

        ppe_issuances = PPEIssuance.objects.all()
        ppe_issued_count = ppe_issuances.aggregate(Sum('quantity'))['quantity__sum'] or 0

        # Процент обеспеченности (выданные СИЗ / запрошенные СИЗ)
        requested_quantity = ppe_requests.aggregate(Sum('quantity'))['quantity__sum'] or 0
        if requested_quantity > 0:
            provision_rate = int((ppe_issued_count / requested_quantity) * 100)
        else:
            provision_rate = 100

        # Распределение СИЗ по категориям для круговой диаграммы
        categories_data = {}
        for issuance in ppe_issuances:
            category = issuance.ppe_item.category
            if category not in categories_data:
                categories_data[category] = 0
            categories_data[category] += issuance.quantity

        # Выдача СИЗ по подразделениям
        departments = Department.objects.all()
        department_ppe_data = []

        for dept in departments[:5]:  # Ограничим только первыми 5 отделами для наглядности
            requested = PPERequest.objects.filter(
                employee__department=dept
            ).aggregate(Sum('quantity'))['quantity__sum'] or 0

            issued = PPEIssuance.objects.filter(
                employee__department=dept
            ).aggregate(Sum('quantity'))['quantity__sum'] or 0

            if requested > 0 or issued > 0:
                department_ppe_data.append({
                    'name': dept.name,
                    'requested': requested,
                    'issued': issued
                })

        # Наиболее востребованные СИЗ
        top_ppe_items = []
        for item in ppe_items[:5]:  # Топ-5 СИЗ
            requested = PPERequest.objects.filter(
                ppe_item=item
            ).aggregate(Sum('quantity'))['quantity__sum'] or 0

            issued = PPEIssuance.objects.filter(
                ppe_item=item
            ).aggregate(Sum('quantity'))['quantity__sum'] or 0

            if requested > 0:
                satisfaction_rate = int((issued / requested) * 100)
            else:
                satisfaction_rate = 0

            top_ppe_items.append({
                'name': item.name,
                'category': item.category,
                'requested': requested,
                'issued': issued,
                'satisfaction_rate': satisfaction_rate
            })

        # Сортировка по количеству запросов
        top_ppe_items.sort(key=lambda x: x['requested'], reverse=True)

        # Последние заявки на СИЗ
        recent_ppe_requests = ppe_requests.select_related(
            'employee', 'employee__user', 'employee__department', 'ppe_item'
        ).order_by('-request_date')[:10]

        context.update({
            'title': 'Использование СИЗ',
            'ppe_requests_count': ppe_requests_count,
            'ppe_issued_count': ppe_issued_count,
            'provision_rate': provision_rate,
            'categories_data': categories_data,
            'department_ppe_data': department_ppe_data,
            'top_ppe_items': top_ppe_items,
            'ppe_requests': recent_ppe_requests
        })

    elif report_type == 'incident_analysis':
        # Анализ происшествий
        incidents = Incident.objects.all()
        incidents_count = incidents.count()

        # Количество несчастных случаев с потерей трудоспособности
        accidents_count = IncidentVictim.objects.filter(
            work_days_lost__gt=0
        ).count()

        # Дни без происшествий
        last_incident = incidents.order_by('-incident_date').first()
        if last_incident:
            incident_free_days = (current_date - last_incident.incident_date.date()).days
        else:
            incident_free_days = 365

        # Динамика происшествий по месяцам
        months = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
                  'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']

        incidents_by_month = []
        for i in range(6):
            month_date = current_date - timedelta(days=30 * i)
            month_start = month_date.replace(day=1)
            if month_date.month == 12:
                month_end = month_date.replace(year=month_date.year + 1, month=1, day=1) - timedelta(days=1)
            else:
                month_end = month_date.replace(month=month_date.month + 1, day=1) - timedelta(days=1)

            count = Incident.objects.filter(
                incident_date__date__gte=month_start,
                incident_date__date__lte=month_end
            ).count()

            incidents_by_month.append({
                'month': months[month_date.month - 1],
                'count': count
            })

        # Происшествия по типам для круговой диаграммы
        incident_types = {}
        for incident in incidents:
            if incident.incident_type not in incident_types:
                incident_types[incident.incident_type] = 0
            incident_types[incident.incident_type] += 1

        # Если нет типов происшествий, добавляем стандартные
        if not incident_types:
            incident_types = {
                'Несчастный случай': 3,
                'Микротравма': 4,
                'Происшествие без травм': 2,
                'Аварийная ситуация': 2,
                'Пожар/возгорание': 1
            }

        # Происшествия по подразделениям
        departments = Department.objects.all()
        department_incidents = []

        for dept in departments[:5]:  # Ограничим только первыми 5 отделами для наглядности
            count = Incident.objects.filter(department=dept).count()
            if count > 0:
                department_incidents.append({
                    'name': dept.name,
                    'count': count
                })

        # Если нет данных по подразделениям, добавляем заглушку
        if not department_incidents:
            department_incidents = [
                {'name': 'Производство', 'count': 7},
                {'name': 'Склад', 'count': 2},
                {'name': 'Монтажный отдел', 'count': 2},
                {'name': 'Сервисная служба', 'count': 1},
                {'name': 'Прочие', 'count': 0}
            ]

        # Анализ корневых причин
        root_causes = {}
        for incident in incidents:
            if incident.root_cause:
                cause = incident.root_cause
                if len(cause) > 50:  # Если слишком длинное описание, берем только начало
                    cause = cause[:50] + "..."

                if cause not in root_causes:
                    root_causes[cause] = 0
                root_causes[cause] += 1

        # Преобразуем в список и сортируем по количеству
        root_causes_data = []
        total_with_causes = sum(root_causes.values())

        for cause, count in root_causes.items():
            if total_with_causes > 0:
                percentage = int((count / total_with_causes) * 100)
            else:
                percentage = 0

            root_causes_data.append({
                'cause': cause,
                'count': count,
                'percentage': percentage
            })

        root_causes_data.sort(key=lambda x: x['count'], reverse=True)

        # Если причин нет, создаем стандартные категории
        if not root_causes_data:
            root_causes_data = [
                {'cause': 'Нарушение требований безопасности', 'count': 5, 'percentage': 42},
                {'cause': 'Технические неисправности', 'count': 3, 'percentage': 25},
                {'cause': 'Отсутствие/неприменение СИЗ', 'count': 2, 'percentage': 17},
                {'cause': 'Недостаточное обучение', 'count': 1, 'percentage': 8},
                {'cause': 'Прочие причины', 'count': 1, 'percentage': 8}
            ]

        # Список последних происшествий
        recent_incidents = incidents.select_related('department').order_by('-incident_date')[:10]

        context.update({
            'title': 'Анализ происшествий',
            'incidents_count': incidents_count,
            'accidents_count': accidents_count,
            'incident_free_days': incident_free_days,
            'incidents_by_month': incidents_by_month,
            'incident_types': incident_types,
            'department_incidents': department_incidents,
            'root_causes_data': root_causes_data,
            'incidents': recent_incidents,
            'current_date': current_date
        })

    elif report_type == 'training_compliance':
        # Соответствие обучения
        instruction_types = InstructionType.objects.all()
        instructions = Instruction.objects.all()
        instructions_count = instructions.count()

        employees = Employee.objects.all()
        employees_count = employees.count()

        # Количество обученных сотрудников (уникальных участников инструктажей)
        participants = InstructionParticipant.objects.values('employee_id').distinct()
        trained_employees = participants.count()

        # Общий уровень соответствия
        if employees_count > 0:
            compliance_percentage = int((trained_employees / employees_count) * 100)
        else:
            compliance_percentage = 100

        # Статистика по типам инструктажей для круговой диаграммы
        instruction_types_data = []

        for type_obj in instruction_types:
            # Количество инструктажей этого типа
            type_instructions = Instruction.objects.filter(instruction_type=type_obj)
            type_count = type_instructions.count()

            # Количество участников
            participants_count = InstructionParticipant.objects.filter(
                instruction__instruction_type=type_obj
            ).count()

            instruction_types_data.append({
                'name': type_obj.name,
                'count': type_count,
                'participants': participants_count
            })

        # Соответствие по подразделениям
        departments = Department.objects.all()
        department_compliance = []

        for dept in departments:
            dept_employees = Employee.objects.filter(department=dept).count()

            if dept_employees > 0:
                # Сотрудники этого отдела, прошедшие инструктаж
                trained_dept_employees = InstructionParticipant.objects.filter(
                    employee__department=dept
                ).values('employee_id').distinct().count()

                compliance_rate = int((trained_dept_employees / dept_employees) * 100)

                department_compliance.append({
                    'name': dept.name,
                    'total': dept_employees,
                    'trained': trained_dept_employees,
                    'compliance_rate': compliance_rate
                })

        # Сортировка по уровню соответствия (по возрастанию, чтобы сначала были проблемные)
        department_compliance.sort(key=lambda x: x['compliance_rate'])

        # Детальная статистика по типам инструктажей
        detailed_instruction_types = []
        for type_obj in instruction_types:
            required_count = 0
            conducted_count = 0

            if type_obj.period_days:  # Если это периодический инструктаж
                # Считаем сколько сотрудников должны его пройти
                required_count = employees_count

                # Считаем сколько сотрудников фактически его прошли
                conducted_count = InstructionParticipant.objects.filter(
                    instruction__instruction_type=type_obj,
                    instruction__instruction_date__gte=current_date - timedelta(days=type_obj.period_days)
                ).values('employee_id').distinct().count()
            else:  # Если непериодический инструктаж (например, вводный)
                # Просто считаем сколько было проведено
                required_count = type_obj.instructions.count()
                conducted_count = type_obj.instructions.count()

            if required_count > 0:
                compliance_rate = int((conducted_count / required_count) * 100)
            else:
                compliance_rate = 100

            detailed_instruction_types.append({
                'name': type_obj.name,
                'required': required_count,
                'conducted': conducted_count,
                'compliance_rate': compliance_rate
            })

        # Подразделения с низким уровнем соответствия
        low_compliance_departments = [dept for dept in department_compliance if dept['compliance_rate'] < 80]

        # Ближайшие инструктажи
        upcoming_instructions = Instruction.objects.filter(
            next_instruction_date__gte=current_date
        ).select_related('instruction_type', 'department').order_by('next_instruction_date')[:10]

        # Для каждого инструктажа считаем количество участников
        for instruction in upcoming_instructions:
            instruction.participants_count = InstructionParticipant.objects.filter(
                instruction=instruction
            ).count()

        context.update({
            'title': 'Соответствие обучения',
            'instructions_count': instructions_count,
            'employees_count': employees_count,
            'trained_employees': trained_employees,
            'compliance_percentage': compliance_percentage,
            'instruction_types_data': instruction_types_data,
            'department_compliance': department_compliance,
            'detailed_instruction_types': detailed_instruction_types,
            'low_compliance_departments': low_compliance_departments,
            'upcoming_instructions': upcoming_instructions,
            'current_date': current_date,
            'next_month': next_month
        })

    return render(request, f'reports/{report_type}.html', context)


# Сотрудники
@login_required
@role_required(['admin', 'department_head', 'medical_worker', 'safety_specialist'])
def employee_list(request):
    employees = Employee.objects.select_related('user', 'department').all()

    # Текущая дата
    current_date = timezone.now().date()

    # Дата через 5 дней (для предупреждения)
    warning_date = current_date + timedelta(days=5)

    # Поиск по имени и фамилии
    search_query = request.GET.get('search', '')
    if search_query:
        employees = employees.filter(
            Q(user__first_name__icontains=search_query) |
            Q(user__last_name__icontains=search_query)
        )

    # Фильтрация по подразделению
    department_filter = request.GET.get('department')
    if department_filter:
        employees = employees.filter(department_id=department_filter)

    # Фильтрация по медосмотрам
    medical_status_filter = request.GET.get('medical_status')
    if medical_status_filter == 'overdue':
        employees = employees.filter(next_medical_exam_date__lt=current_date)
    elif medical_status_filter == 'warning':
        employees = employees.filter(next_medical_exam_date__gte=current_date,
                                     next_medical_exam_date__lte=warning_date)
    elif medical_status_filter == 'upcoming':
        employees = employees.filter(next_medical_exam_date__gt=warning_date)

    # Фильтрация по дате следующего медосмотра
    next_exam_from = request.GET.get('next_exam_from')
    if next_exam_from:
        try:
            next_exam_from_date = datetime.strptime(next_exam_from, '%Y-%m-%d').date()
            employees = employees.filter(next_medical_exam_date__gte=next_exam_from_date)
        except ValueError:
            pass

    next_exam_to = request.GET.get('next_exam_to')
    if next_exam_to:
        try:
            next_exam_to_date = datetime.strptime(next_exam_to, '%Y-%m-%d').date()
            employees = employees.filter(next_medical_exam_date__lte=next_exam_to_date)
        except ValueError:
            pass

    # Отправка уведомлений выбранным сотрудникам
    if request.method == 'POST' and 'send_notification' in request.POST:
        employee_ids = request.POST.getlist('selected_employees')
        if employee_ids:
            for employee_id in employee_ids:
                employee = Employee.objects.get(id=employee_id)

                # Создаем уведомление о необходимости пройти медосмотр
                notification = Notification.objects.create(
                    user=employee.user,
                    title='Необходимо пройти медосмотр',
                    message=f'Вам необходимо пройти медицинский осмотр. Пожалуйста, обратитесь в медицинский отдел для согласования даты.',
                    notification_type='medical',
                    related_entity_type='employee',
                    related_entity_id=employee.id,
                    is_read=False
                )

            messages.success(request, f'Уведомления успешно отправлены {len(employee_ids)} сотрудникам.')

            # Перенаправляем на ту же страницу, чтобы избежать повторной отправки при обновлении
            return redirect('employee_list')

    # Пагинация
    paginator = Paginator(employees, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Список отделов для фильтра
    departments = Department.objects.all()

    # Для подсветки просроченных/приближающихся дат медосмотра
    for employee in page_obj:
        if employee.next_medical_exam_date:
            if employee.next_medical_exam_date < current_date:
                employee.medical_status = 'overdue'
            elif employee.next_medical_exam_date <= warning_date:
                employee.medical_status = 'warning'
            else:
                employee.medical_status = 'normal'
        else:
            employee.medical_status = 'none'

    context = {
        'page_obj': page_obj,
        'departments': departments,
        'department_filter': department_filter,
        'medical_status_filter': medical_status_filter,
        'next_exam_from': next_exam_from,
        'next_exam_to': next_exam_to,
        'current_date': current_date,
        'warning_date': warning_date,
        'is_medical_worker': request.user.employee.role == 'medical_worker' if hasattr(request.user,
                                                                                       'employee') else False,
        'search_query': search_query,
    }
    return render(request, 'employees/employee_list.html', context)
@login_required
def employee_detail(request, pk):
    employee = get_object_or_404(Employee, pk=pk)

    # История инструктажей
    instruction_history = InstructionParticipant.objects.filter(
        employee=employee
    ).select_related('instruction', 'instruction__instruction_type').order_by('-instruction__instruction_date')

    # История выдачи СИЗ
    ppe_history = PPEIssuance.objects.filter(
        employee=employee
    ).select_related('ppe_item').order_by('-issue_date')

    # Медицинские осмотры
    medical_exams = MedicalExamination.objects.filter(
        employee=employee
    ).order_by('-exam_date')

    context = {
        'employee': employee,
        'instruction_history': instruction_history,
        'ppe_history': ppe_history,
        'medical_exams': medical_exams,
    }
    return render(request, 'employees/employee_detail.html', context)


@login_required
def employee_create(request):
    if request.method == 'POST':
        # Сначала создаем пользователя
        username = request.POST.get('username')
        password = request.POST.get('password')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        email = request.POST.get('email')

        # Проверяем, не существует ли уже пользователь с таким именем
        if User.objects.filter(username=username).exists():
            messages.error(request, 'Пользователь с таким именем уже существует.')
            return redirect('employee_create')

        # Временно отключаем сигнал create_employee_if_missing
        post_save.disconnect(create_employee_if_missing, sender=User)

        try:
            # Создаем пользователя
            user = User.objects.create_user(
                username=username,
                password=password,
                first_name=first_name,
                last_name=last_name,
                email=email
            )

            # Затем создаем сотрудника, связанного с пользователем
            form = EmployeeForm(request.POST)
            if form.is_valid():
                employee = form.save(commit=False)
                employee.user = user
                employee.save()
                messages.success(request, 'Сотрудник успешно добавлен.')
                return redirect('employee_list')
        finally:
            # Снова подключаем сигнал
            post_save.connect(create_employee_if_missing, sender=User)
    else:
        form = EmployeeForm()

    context = {
        'form': form,
        'title': 'Добавление сотрудника'
    }
    return render(request, 'employees/employee_form.html', context)
@login_required
def employee_update(request, pk):
    employee = get_object_or_404(Employee, pk=pk)

    if request.method == 'POST':
        form = EmployeeForm(request.POST, instance=employee)
        if form.is_valid():
            form.save()
            messages.success(request, 'Данные сотрудника успешно обновлены.')
            return redirect('employee_detail', pk=employee.pk)
    else:
        form = EmployeeForm(instance=employee)

    context = {
        'form': form,
        'employee': employee,
        'title': 'Редактирование сотрудника'
    }
    return render(request, 'employees/employee_form.html', context)


@login_required
def employee_delete(request, pk):
    employee = get_object_or_404(Employee, pk=pk)

    if request.method == 'POST':
        # Удаление связанного пользователя также удалит и сотрудника из-за on_delete=CASCADE
        employee.user.delete()
        messages.success(request, 'Сотрудник успешно удален.')
        return redirect('employee_list')

    context = {
        'employee': employee
    }
    return render(request, 'employees/employee_confirm_delete.html', context)


# Оборудование
@login_required
def equipment_list(request):
    equipment = Equipment.objects.select_related('department', 'responsible_person').all().order_by('name')

    # Фильтрация
    status_filter = request.GET.get('status')
    if status_filter:
        equipment = equipment.filter(status=status_filter)

    # Пагинация
    paginator = Paginator(equipment, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Текущая дата
    current_date = timezone.now().date()

    # Данные для графика по статусам оборудования
    equipment_status_chart_data = Equipment.objects.values('status').annotate(
        count=Count('id')
    ).order_by('status')

    equipment_status_labels = [
        'Исправно' if item['status'] == 'operational' else
        'Требуется ТО' if item['status'] == 'requires_maintenance' else
        'На обслуживании' if item['status'] == 'under_maintenance' else
        'Выведено из эксплуатации' for item in equipment_status_chart_data
    ]
    equipment_status_counts = [item['count'] for item in equipment_status_chart_data]

    # Данные для графика по типам оборудования
    equipment_types_chart_data = Equipment.objects.values('equipment_type').annotate(
        count=Count('id')
    ).order_by('-count')[:5]  # Топ-5 типов оборудования

    equipment_types_labels = [item['equipment_type'] for item in equipment_types_chart_data]
    equipment_types_counts = [item['count'] for item in equipment_types_chart_data]

    context = {
        'page_obj': page_obj,
        'status_filter': status_filter,
        'current_date': current_date,
        'equipment_status_labels': json.dumps(equipment_status_labels),
        'equipment_status_counts': json.dumps(equipment_status_counts),
        'equipment_types_labels': json.dumps(equipment_types_labels),
        'equipment_types_counts': json.dumps(equipment_types_counts),
    }
    return render(request, 'equipment/equipment_list.html', context)


@login_required
def equipment_detail(request, pk):
    equipment_item = get_object_or_404(Equipment, pk=pk)

    # История обслуживания
    maintenance_history = EquipmentMaintenance.objects.filter(
        equipment=equipment_item
    ).order_by('-maintenance_date')

    context = {
        'equipment': equipment_item,
        'maintenance_history': maintenance_history,
    }
    return render(request, 'equipment/equipment_detail.html', context)


@login_required
def equipment_create(request):
    if request.method == 'POST':
        form = EquipmentForm(request.POST)
        if form.is_valid():
            equipment = form.save()
            messages.success(request, 'Оборудование успешно добавлено.')
            return redirect('equipment_list')
    else:
        form = EquipmentForm()

    context = {
        'form': form,
        'title': 'Добавление оборудования'
    }
    return render(request, 'equipment/equipment_form.html', context)


@login_required
def equipment_update(request, pk):
    equipment_item = get_object_or_404(Equipment, pk=pk)

    if request.method == 'POST':
        form = EquipmentForm(request.POST, instance=equipment_item)
        if form.is_valid():
            form.save()
            messages.success(request, 'Данные оборудования успешно обновлены.')
            return redirect('equipment_detail', pk=equipment_item.pk)
    else:
        form = EquipmentForm(instance=equipment_item)

    context = {
        'form': form,
        'equipment': equipment_item,
        'title': 'Редактирование оборудования'
    }
    return render(request, 'equipment/equipment_form.html', context)


@login_required
def equipment_delete(request, pk):
    equipment_item = get_object_or_404(Equipment, pk=pk)

    if request.method == 'POST':
        equipment_item.delete()
        messages.success(request, 'Оборудование успешно удалено.')
        return redirect('equipment_list')

    context = {
        'equipment': equipment_item
    }
    return render(request, 'equipment/equipment_confirm_delete.html', context)


@login_required
def equipment_maintenance(request, pk):
    equipment_item = get_object_or_404(Equipment, pk=pk)

    if request.method == 'POST':
        # Предполагаемая форма для обслуживания оборудования
        form = EquipmentMaintenanceForm(request.POST)
        if form.is_valid():
            maintenance = form.save(commit=False)
            maintenance.equipment = equipment_item
            maintenance.performed_by = request.user
            maintenance.save()

            # Обновить дату следующего обслуживания в оборудовании
            equipment_item.last_maintenance_date = maintenance.maintenance_date
            equipment_item.next_maintenance_date = maintenance.next_maintenance_date
            equipment_item.save()

            messages.success(request, 'Запись об обслуживании оборудования успешно добавлена.')
            return redirect('equipment_detail', pk=equipment_item.pk)
    else:
        form = EquipmentMaintenanceForm()

    context = {
        'form': form,
        'equipment': equipment_item,
        'title': 'Обслуживание оборудования'
    }
    return render(request, 'equipment/maintenance_form.html', context)


# Уведомления
@login_required
def notifications(request):
    notifications = Notification.objects.filter(user=request.user).order_by('-created_at')

    # Пагинация
    paginator = Paginator(notifications, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
    }
    return render(request, 'notifications/notification_list.html', context)


@login_required
def notification_mark_read(request, pk):
    """Отметить отдельное уведомление как прочитанное"""
    notification = get_object_or_404(Notification, pk=pk, user=request.user)
    notification.is_read = True
    notification.save()

    # Если это AJAX-запрос, возвращаем JSON-ответ
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({'status': 'success'})

    # Иначе перенаправляем обратно на страницу уведомлений
    return redirect('notifications')


@login_required
def notifications_mark_all_read(request):
    """Отметить все уведомления пользователя как прочитанные"""
    Notification.objects.filter(user=request.user, is_read=False).update(is_read=True)

    # Если это AJAX-запрос, возвращаем JSON-ответ
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({'status': 'success'})

    # Показываем сообщение пользователю
    messages.success(request, 'Все уведомления отмечены как прочитанные.')

    # Перенаправляем обратно на страницу уведомлений
    return redirect('notifications')

# API для AJAX запросов
@login_required
def api_stats(request):
    # Статистика для обновления на дашборде через AJAX
    last_incident = Incident.objects.order_by('-incident_date').first()
    if last_incident:
        incident_free_days = (timezone.now().date() - last_incident.incident_date.date()).days
    else:
        incident_free_days = 365

    identified_risks_count = Risk.objects.count()

    total_findings = InspectionFinding.objects.count()
    resolved_findings = InspectionFinding.objects.filter(status='completed').count()
    compliance_percentage = 100 if total_findings == 0 else int((resolved_findings / total_findings) * 100)

    data = {
        'incident_free_days': incident_free_days,
        'identified_risks_count': identified_risks_count,
        'compliance_percentage': compliance_percentage,
    }

    return JsonResponse(data)


@login_required
def api_notifications(request):
    count = Notification.objects.filter(user=request.user, is_read=False).count()
    latest = Notification.objects.filter(user=request.user, is_read=False).order_by('-created_at')[:5].values('id',
                                                                                                              'title',
                                                                                                              'message',
                                                                                                              'created_at')


    for item in latest:
        item['created_at'] = item['created_at'].strftime('%Y-%m-%d %H:%M:%S')

    data = {
        'count': count,
        'latest': list(latest),
    }

    return JsonResponse(data)


def login_view(request):
    if request.method == 'POST':
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            username = form.cleaned_data.get('username')
            password = form.cleaned_data.get('password')
            user = authenticate(username=username, password=password)

            if user is not None:
                if user.is_active:
                    login(request, user)
                    next_page = request.GET.get('next', 'dashboard')
                    return redirect(next_page)
                else:
                    messages.error(request, 'Ваша учетная запись отключена.')
            else:
                messages.error(request, 'Неверное имя пользователя или пароль.')
    else:
        form = AuthenticationForm()

    return render(request, 'auth/login.html', {'form': form})


def logout_view(request):
    logout(request)
    messages.success(request, 'Вы успешно вышли из системы.')
    return redirect('login')


@receiver(user_logged_in)
def user_logged_in_callback(sender, request, user, **kwargs):
    ip_address = request.META.get('REMOTE_ADDR', '')
    user_agent = request.META.get('HTTP_USER_AGENT', '')

    UserLog.objects.create(
        user=user,
        action='login',
        ip_address=ip_address,
        user_agent=user_agent,
        details={
            'method': 'web_interface'
        }
    )


@receiver(user_logged_out)
def user_logged_out_callback(sender, request, user, **kwargs):
    if user:
        ip_address = request.META.get('REMOTE_ADDR', '')
        user_agent = request.META.get('HTTP_USER_AGENT', '')

        UserLog.objects.create(
            user=user,
            action='logout',
            ip_address=ip_address,
            user_agent=user_agent,
            details={
                'method': 'web_interface'
            }
        )


# Функция для медицинских осмотров
@login_required
@role_required(['admin', 'medical_worker'])
def medical_exam_list(request):
    # Получаем все медицинские осмотры
    exams = MedicalExamination.objects.select_related('employee', 'employee__user', 'employee__department').all()

    # Фильтрация
    department_filter = request.GET.get('department')
    if department_filter:
        exams = exams.filter(employee__department_id=department_filter)

    status_filter = request.GET.get('status')
    current_date = now().date()
    next_month = current_date + timedelta(days=30)

    if status_filter == 'overdue':
        exams = exams.filter(next_exam_date__lt=current_date)
    elif status_filter == 'upcoming':
        exams = exams.filter(next_exam_date__gte=current_date, next_exam_date__lte=next_month)
    elif status_filter == 'completed':
        exams = exams.filter(next_exam_date__gt=next_month)

    # Пагинация
    paginator = Paginator(exams.order_by('-exam_date'), 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Список отделов для фильтра
    departments = Department.objects.all()

    context = {
        'page_obj': page_obj,
        'departments': departments,
        'department_filter': department_filter,
        'status_filter': status_filter,
        'current_date': current_date,
        'next_month': next_month
    }
    return render(request, 'medical_exams/medical_exam_list.html', context)


@login_required
@role_required(['admin', 'medical_worker'])
def medical_exam_create(request, employee_id=None):
    if request.method == 'POST':
        form = MedicalExaminationForm(request.POST, request.FILES)
        if form.is_valid():
            exam = form.save()

            # Обновляем даты медосмотра у сотрудника
            employee = exam.employee
            employee.medical_exam_date = exam.exam_date
            employee.next_medical_exam_date = exam.next_exam_date
            employee.save()

            messages.success(request, 'Медицинский осмотр успешно добавлен.')
            return redirect('medical_exam_detail', pk=exam.pk)
    else:
        initial = {}
        if employee_id:
            initial['employee'] = employee_id
        form = MedicalExaminationForm(initial=initial)

    context = {
        'form': form,
        'title': 'Добавление медицинского осмотра'
    }
    return render(request, 'medical_exams/medical_exam_form.html', context)


@login_required
@role_required(['admin', 'medical_worker'])
def medical_exam_detail(request, pk):
    medical_exam = get_object_or_404(MedicalExamination, pk=pk)

    # История медосмотров сотрудника
    employee_exams = MedicalExamination.objects.filter(
        employee=medical_exam.employee
    ).order_by('-exam_date')

    current_date = now().date()
    next_month = current_date + timedelta(days=30)

    context = {
        'medical_exam': medical_exam,
        'employee_exams': employee_exams,
        'current_date': current_date,
        'next_month': next_month
    }
    return render(request, 'medical_exams/medical_exam_detail.html', context)


@login_required
@role_required(['admin', 'medical_worker'])
def medical_exam_update(request, pk):
    medical_exam = get_object_or_404(MedicalExamination, pk=pk)

    if request.method == 'POST':
        form = MedicalExaminationForm(request.POST, request.FILES, instance=medical_exam)
        if form.is_valid():
            exam = form.save()

            # Обновляем даты медосмотра у сотрудника
            employee = exam.employee
            employee.medical_exam_date = exam.exam_date
            employee.next_medical_exam_date = exam.next_exam_date
            employee.save()

            messages.success(request, 'Данные медицинского осмотра успешно обновлены.')
            return redirect('medical_exam_detail', pk=exam.pk)
    else:
        form = MedicalExaminationForm(instance=medical_exam)

    context = {
        'form': form,
        'medical_exam': medical_exam,
        'title': 'Редактирование медицинского осмотра'
    }
    return render(request, 'medical_exams/medical_exam_form.html', context)


@login_required
@role_required(['admin', 'medical_worker'])
def medical_exam_delete(request, pk):
    medical_exam = get_object_or_404(MedicalExamination, pk=pk)

    if request.method == 'POST':
        # Сохраняем ссылку на сотрудника
        employee = medical_exam.employee

        # Удаляем медосмотр
        medical_exam.delete()

        # Обновляем даты медосмотра у сотрудника (находим последний медосмотр)
        last_exam = MedicalExamination.objects.filter(employee=employee).order_by('-exam_date').first()
        if last_exam:
            employee.medical_exam_date = last_exam.exam_date
            employee.next_medical_exam_date = last_exam.next_exam_date
            employee.save()

        messages.success(request, 'Медицинский осмотр успешно удален.')
        return redirect('medical_exam_list')

    context = {
        'medical_exam': medical_exam
    }
    return render(request, 'medical_exams/medical_exam_delete.html', context)


# Функции для истории обслуживания оборудования
@login_required
def equipment_maintenance_list(request):
    # Получаем все записи обслуживания
    maintenance_records = EquipmentMaintenance.objects.select_related(
        'equipment', 'performed_by'
    ).all()

    # Фильтрация
    equipment_filter = request.GET.get('equipment')
    if equipment_filter:
        maintenance_records = maintenance_records.filter(equipment_id=equipment_filter)

    type_filter = request.GET.get('maintenance_type')
    if type_filter:
        maintenance_records = maintenance_records.filter(maintenance_type=type_filter)

    # Пагинация
    paginator = Paginator(maintenance_records.order_by('-maintenance_date'), 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    # Список оборудования для фильтра
    equipment_items = Equipment.objects.all()

    # Список типов обслуживания для фильтра
    maintenance_types = EquipmentMaintenance.objects.values_list('maintenance_type', flat=True).distinct()

    # Оборудование, требующее обслуживания
    current_date = now().date()
    equipment_needs_maintenance = Equipment.objects.filter(
        Q(next_maintenance_date__lt=current_date) |
        Q(status='requires_maintenance')
    ).order_by('next_maintenance_date')[:5]

    # Статистика для графиков
    maintenance_types_stats = EquipmentMaintenance.objects.values('maintenance_type').annotate(
        count=Count('id')
    ).order_by('-count')

    maintenance_types_stats_labels = json.dumps([item['maintenance_type'] for item in maintenance_types_stats])
    maintenance_types_stats_data = json.dumps([item['count'] for item in maintenance_types_stats])

    # Статистика по месяцам (за последний год)
    year_ago = now() - timedelta(days=365)
    maintenance_by_month = EquipmentMaintenance.objects.filter(
        maintenance_date__gte=year_ago
    ).extra(
        {'month': "to_char(maintenance_date, 'MM.YYYY')"}
    ).values('month').annotate(
        count=Count('id')
    ).order_by('month')

    maintenance_months_labels = json.dumps([item['month'] for item in maintenance_by_month])
    maintenance_months_data = json.dumps([item['count'] for item in maintenance_by_month])

    context = {
        'page_obj': page_obj,
        'equipment_items': equipment_items,
        'maintenance_types': maintenance_types,
        'equipment_filter': equipment_filter,
        'type_filter': type_filter,
        'current_date': current_date,
        'equipment_needs_maintenance': equipment_needs_maintenance,
        'maintenance_types_stats_labels': maintenance_types_stats_labels,
        'maintenance_types_stats_data': maintenance_types_stats_data,
        'maintenance_months_labels': maintenance_months_labels,
        'maintenance_months_data': maintenance_months_data
    }
    return render(request, 'equipment/equipment_maintenance_list.html', context)


@login_required
def maintenance_detail(request, pk):
    maintenance = get_object_or_404(EquipmentMaintenance, pk=pk)

    # История обслуживания данного оборудования
    equipment_maintenance_history = EquipmentMaintenance.objects.filter(
        equipment=maintenance.equipment
    ).order_by('-maintenance_date')

    current_date = now().date()

    context = {
        'maintenance': maintenance,
        'equipment_maintenance_history': equipment_maintenance_history,
        'current_date': current_date
    }
    return render(request, 'equipment/maintenance_detail.html', context)


@login_required
def report_custom(request):
    """Формирование пользовательских отчетов"""
    report_type = request.GET.get('report_type', 'monthly')
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')

    context = {
        'report_type': report_type,
        'date_from': date_from,
        'date_to': date_to,
        'title': 'Пользовательский отчет'
    }

    if report_type == 'monthly':
        context['title'] = 'Ежемесячный отчет'
        return render(request, 'reports/monthly_report.html', context)
    elif report_type == 'quarterly':
        context['title'] = 'Квартальный отчет'
        return render(request, 'reports/quarterly_report.html', context)
    elif report_type == 'annual':
        context['title'] = 'Годовой отчет'
        return render(request, 'reports/annual_report.html', context)
    elif report_type == 'department':
        context['title'] = 'Отчет по подразделению'
        return render(request, 'reports/department_report.html', context)
    else:
        return render(request, 'reports/custom_report.html', context)

@login_required
def maintenance_update(request, pk):
    maintenance = get_object_or_404(EquipmentMaintenance, pk=pk)

    if request.method == 'POST':
        form = EquipmentMaintenanceForm(request.POST, instance=maintenance)
        if form.is_valid():
            maintenance = form.save()

            # Обновляем даты обслуживания в оборудовании
            equipment = maintenance.equipment
            equipment.last_maintenance_date = maintenance.maintenance_date
            equipment.next_maintenance_date = maintenance.next_maintenance_date

            # Обновляем статус оборудования
            if equipment.status == 'under_maintenance':
                equipment.status = 'operational'

            equipment.save()

            messages.success(request, 'Данные обслуживания успешно обновлены.')
            return redirect('maintenance_detail', pk=maintenance.pk)
    else:
        form = EquipmentMaintenanceForm(instance=maintenance)

    context = {
        'form': form,
        'maintenance': maintenance,
        'title': 'Редактирование записи обслуживания'
    }
    return render(request, 'equipment/maintenance_update.html', context)


def get_medical_exam_statistics():
    """
    Функция для получения статистики по медицинским осмотрам.
    Можно использовать в представлениях dashboard, reports и т.д.
    """
    current_date = timezone.now().date()
    warning_date = current_date + timedelta(days=5)
    next_month = current_date + timedelta(days=30)

    # Общая статистика
    total_employees = Employee.objects.count()
    employees_with_exams = Employee.objects.filter(next_medical_exam_date__isnull=False).count()

    # Статистика по просроченным/приближающимся медосмотрам
    overdue_count = Employee.objects.filter(next_medical_exam_date__lt=current_date).count()
    upcoming_count = Employee.objects.filter(
        next_medical_exam_date__gte=current_date,
        next_medical_exam_date__lte=warning_date
    ).count()
    monthly_count = Employee.objects.filter(
        next_medical_exam_date__gt=warning_date,
        next_medical_exam_date__lte=next_month
    ).count()

    # Рассчитываем процент охвата и соответствия
    coverage_percent = 0
    compliance_percent = 0

    if total_employees > 0:
        coverage_percent = int((employees_with_exams / total_employees) * 100)

    if employees_with_exams > 0:
        compliance_percent = int(((employees_with_exams - overdue_count) / employees_with_exams) * 100)

    # Статистика по типам медосмотров
    exam_types = MedicalExamination.objects.values('exam_type').annotate(
        count=Count('id')
    ).order_by('-count')

    # Статистика по месяцам
    last_year = current_date - timedelta(days=365)
    exams_by_month = MedicalExamination.objects.filter(
        exam_date__gte=last_year
    ).annotate(
        month=TruncMonth('exam_date')
    ).values('month').annotate(
        count=Count('id')
    ).order_by('month')

    # Формируем данные по месяцам для графика
    months_labels = []
    months_counts = []

    for item in exams_by_month:
        months_labels.append(item['month'].strftime('%b %Y'))
        months_counts.append(item['count'])

    # Формируем данные по типам для графика
    types_labels = []
    types_counts = []

    for item in exam_types:
        types_labels.append(item['exam_type'])
        types_counts.append(item['count'])

    return {
        'total_employees': total_employees,
        'employees_with_exams': employees_with_exams,
        'overdue_count': overdue_count,
        'upcoming_count': upcoming_count,
        'monthly_count': monthly_count,
        'coverage_percent': coverage_percent,
        'compliance_percent': compliance_percent,
        'exam_types': exam_types,
        'months_labels': months_labels,
        'months_counts': months_counts,
        'types_labels': types_labels,
        'types_counts': types_counts,
    }

@login_required
def task_create(request):
    if request.method == 'POST':
        task_type = request.POST.get('task_type')

        if task_type == 'ppe':
            return redirect('ppe_create')
        elif task_type == 'instruction':
            return redirect('instruction_create')
        elif task_type == 'inspection':
            return redirect('inspection_create')
        elif task_type == 'risk':
            return redirect('risk_create')
        else:
            # Общая форма задачи
            form = SafetyTaskForm(request.POST)
            if form.is_valid():
                task = form.save(commit=False)
                task.assigned_by = request.user
                task.save()
                messages.success(request, 'Задача успешно создана.')
                return redirect('dashboard')
    else:
        form = SafetyTaskForm()

    context = {
        'form': form,
        'title': 'Создание задачи'
    }
    return render(request, 'tasks/task_form.html', context)


@login_required
def ppe_process(request, pk):
    """Обработка заявки на СИЗ"""
    ppe_request = get_object_or_404(PPERequest, pk=pk)

    if request.method == 'POST':
        status = request.POST.get('status')
        notes = request.POST.get('notes')

        if status:
            ppe_request.status = status
            ppe_request.notes = notes
            ppe_request.processed_by = request.user
            ppe_request.processed_date = timezone.now()
            ppe_request.save()

            messages.success(request, 'Статус заявки успешно изменен.')

        return redirect('ppe_detail', pk=ppe_request.pk)

    context = {
        'ppe_request': ppe_request
    }
    return render(request, 'ppe/ppe_process.html', context)


@login_required
def ppe_issue(request, pk):
    """Выдача СИЗ по заявке"""
    ppe_request = get_object_or_404(PPERequest, pk=pk)

    if request.method == 'POST':
        quantity = request.POST.get('quantity', ppe_request.quantity)
        expected_return_date = request.POST.get('expected_return_date')
        notes = request.POST.get('notes')

        issuance = PPEIssuance(
            request=ppe_request,
            employee=ppe_request.employee,
            ppe_item=ppe_request.ppe_item,
            quantity=quantity,
            issued_by=request.user,
            notes=notes
        )

        if expected_return_date:
            issuance.expected_return_date = expected_return_date

        issuance.save()

        # Обновляем статус заявки
        ppe_request.status = 'completed'
        ppe_request.processed_by = request.user
        ppe_request.processed_date = timezone.now()
        ppe_request.save()

        messages.success(request, 'СИЗ успешно выдано.')
        return redirect('ppe_detail', pk=ppe_request.pk)

    context = {
        'ppe_request': ppe_request
    }
    return render(request, 'ppe/ppe_issue.html', context)


@login_required
def ppe_issue_employee(request, employee_id):
    """Выдача СИЗ сотруднику напрямую (без заявки)"""
    employee = get_object_or_404(Employee, pk=employee_id)

    if request.method == 'POST':
        ppe_item_id = request.POST.get('ppe_item')
        quantity = request.POST.get('quantity', 1)
        expected_return_date = request.POST.get('expected_return_date')
        notes = request.POST.get('notes')

        if ppe_item_id:
            ppe_item = get_object_or_404(PPEItem, pk=ppe_item_id)

            issuance = PPEIssuance(
                employee=employee,
                ppe_item=ppe_item,
                quantity=quantity,
                issued_by=request.user,
                notes=notes
            )

            if expected_return_date:
                issuance.expected_return_date = expected_return_date

            issuance.save()

            messages.success(request, f'СИЗ успешно выдано {employee}.')
            return redirect('employee_detail', pk=employee_id)

    # Список доступных СИЗ
    ppe_items = PPEItem.objects.all()

    context = {
        'employee': employee,
        'ppe_items': ppe_items
    }
    return render(request, 'ppe/ppe_issue_employee.html', context)


@login_required
def inspection_complete(request, pk):
    """Завершение проверки и добавление результатов"""
    inspection = get_object_or_404(Inspection, pk=pk)

    if request.method == 'POST':
        end_date = request.POST.get('end_date')
        result = request.POST.get('result')
        status = request.POST.get('status', 'completed')

        inspection.end_date = end_date
        inspection.result = result
        inspection.status = status

        # Если загружен отчет, сохраняем его
        if 'report' in request.FILES:
            report = request.FILES['report']
            # Здесь должна быть логика сохранения файла
            # inspection.report_path = saved_path_to_file

        inspection.save()

        messages.success(request, 'Проверка успешно завершена.')
        return redirect('inspection_detail', pk=inspection.pk)

    context = {
        'inspection': inspection
    }
    return render(request, 'inspections/inspection_complete.html', context)


@login_required
def inspection_finding_create(request, inspection_id):
    """Добавление нарушения к проверке"""
    inspection = get_object_or_404(Inspection, pk=inspection_id)

    if request.method == 'POST':
        form = InspectionFindingForm(request.POST)
        if form.is_valid():
            finding = form.save(commit=False)
            finding.inspection = inspection
            finding.save()

            messages.success(request, 'Нарушение успешно добавлено.')
            return redirect('inspection_detail', pk=inspection_id)
    else:
        form = InspectionFindingForm()

    context = {
        'form': form,
        'inspection': inspection,
        'title': 'Добавление нарушения'
    }
    return render(request, 'inspections/finding_form.html', context)


@login_required
def inspection_finding_update(request, pk):
    """Редактирование нарушения"""
    finding = get_object_or_404(InspectionFinding, pk=pk)

    if request.method == 'POST':
        form = InspectionFindingForm(request.POST, instance=finding)
        if form.is_valid():
            form.save()

            messages.success(request, 'Нарушение успешно обновлено.')
            return redirect('inspection_detail', pk=finding.inspection.pk)
    else:
        form = InspectionFindingForm(instance=finding)

    context = {
        'form': form,
        'finding': finding,
        'title': 'Редактирование нарушения'
    }
    return render(request, 'inspections/finding_form.html', context)


@login_required
def inspection_finding_delete(request, pk):
    """Удаление нарушения"""
    finding = get_object_or_404(InspectionFinding, pk=pk)
    inspection_id = finding.inspection.pk

    if request.method == 'POST':
        finding.delete()
        messages.success(request, 'Нарушение успешно удалено.')
        return redirect('inspection_detail', pk=inspection_id)

    context = {
        'finding': finding
    }
    return render(request, 'inspections/finding_confirm_delete.html', context)


@login_required
def risk_mitigation_add(request, risk_id):
    """Добавление мероприятия по снижению риска"""
    risk = get_object_or_404(Risk, pk=risk_id)

    if request.method == 'POST':
        form = RiskMitigationMeasureForm(request.POST)
        if form.is_valid():
            measure = form.save(commit=False)
            measure.risk = risk
            measure.save()

            messages.success(request, 'Мероприятие по снижению риска успешно добавлено.')
            return redirect('risk_detail', pk=risk_id)
    else:
        form = RiskMitigationMeasureForm()

    context = {
        'form': form,
        'risk': risk,
        'title': 'Добавление мероприятия по снижению риска'
    }
    return render(request, 'risks/risk_mitigation_form.html', context)


@login_required
def risk_mitigation_update(request, pk):
    """Редактирование мероприятия по снижению риска"""
    measure = get_object_or_404(RiskMitigationMeasure, pk=pk)

    if request.method == 'POST':
        form = RiskMitigationMeasureForm(request.POST, instance=measure)
        if form.is_valid():
            form.save()

            messages.success(request, 'Мероприятие по снижению риска успешно обновлено.')
            return redirect('risk_detail', pk=measure.risk.pk)
    else:
        form = RiskMitigationMeasureForm(instance=measure)

    context = {
        'form': form,
        'measure': measure,
        'title': 'Редактирование мероприятия по снижению риска'
    }
    return render(request, 'risks/risk_mitigation_form.html', context)


def metrics_view(request):
    try:
        conn = psycopg2.connect(
            dbname=settings.DATABASES['default']['NAME'],
            user=settings.DATABASES['default']['USER'],
            password=settings.DATABASES['default']['PASSWORD'],
            host=settings.DATABASES['default']['HOST'],
            port=settings.DATABASES['default']['PORT']
        )
        cur = conn.cursor()
        cur.execute("SELECT pg_database_size(%s)", (settings.DATABASES['default']['NAME'],))
        size = cur.fetchone()[0]
        database_size_gauge.set(size)
        cur.close()
        conn.close()
    except:
        pass

    metrics = generate_latest()
    return HttpResponse(metrics, content_type='text/plain')
@login_required
def risk_mitigation_delete(request, pk):
    """Удаление мероприятия по снижению риска"""
    measure = get_object_or_404(RiskMitigationMeasure, pk=pk)
    risk_id = measure.risk.pk

    if request.method == 'POST':
        measure.delete()
        messages.success(request, 'Мероприятие по снижению риска успешно удалено.')
        return redirect('risk_detail', pk=risk_id)

    context = {
        'measure': measure
    }
    return render(request, 'risks/risk_mitigation_confirm_delete.html', context)


@login_required
@role_required(['admin', 'safety_specialist'])
def evacuation_notification_create(request):
    """Создание уведомления об эвакуации"""
    if request.method == 'POST':
        title = request.POST.get('title', 'Внимание! Необходима эвакуация!')
        message = request.POST.get('message',
                                   'Требуется немедленная эвакуация из здания. Следуйте указаниям ответственных лиц.')
        department_id = request.POST.get('department')

        # Создаем уведомление об эвакуации
        evacuation = EvacuationNotification.objects.create(
            title=title,
            message=message,
            created_by=request.user,
            is_active=True
        )

        # Если выбрано конкретное подразделение
        if department_id and department_id != 'all':
            try:
                department = Department.objects.get(id=department_id)
                evacuation.department = department
                evacuation.save()

                # Отправляем уведомление сотрудникам подразделения
                employees = Employee.objects.filter(department=department)
                for employee in employees:
                    Notification.objects.create(
                        user=employee.user,
                        title=title,
                        message=message,
                        notification_type='evacuation',
                        is_read=False
                    )

                messages.success(request, f'Уведомление об эвакуации отправлено в подразделение {department.name}')
            except Department.DoesNotExist:
                messages.error(request, 'Выбранное подразделение не найдено.')
        else:
            # Отправляем уведомление всем сотрудникам
            all_users = User.objects.filter(is_active=True)
            for user in all_users:
                Notification.objects.create(
                    user=user,
                    title=title,
                    message=message,
                    notification_type='evacuation',
                    is_read=False
                )

            messages.success(request, 'Уведомление об эвакуации отправлено всем сотрудникам')

        return redirect('dashboard')

    # Список отделов для выбора
    departments = Department.objects.all()

    context = {
        'departments': departments,
        'title': 'Создание уведомления об эвакуации'
    }
    return render(request, 'evacuation/evacuation_form.html', context)


@login_required
def evacuation_check(request):
    """API для проверки активных уведомлений об эвакуации для пользователя"""
    evacuation_notifications = []

    try:
        user = request.user
        employee = user.employee

        # Проверяем наличие активных уведомлений об эвакуации
        # Для всех сотрудников
        all_evacuations = EvacuationNotification.objects.filter(
            department__isnull=True,
            is_active=True
        )

        # Для подразделения сотрудника
        if employee.department:
            department_evacuations = EvacuationNotification.objects.filter(
                department=employee.department,
                is_active=True
            )
            all_evacuations = all_evacuations | department_evacuations

        # Недавние уведомления (за последние 30 минут)
        recent_time = timezone.now() - timedelta(minutes=30)
        all_evacuations = all_evacuations.filter(created_at__gte=recent_time)

        # Преобразуем в список словарей для JSON
        for evacuation in all_evacuations:
            evacuation_notifications.append({
                'id': evacuation.id,
                'title': evacuation.title,
                'message': evacuation.message,
                'created_at': evacuation.created_at.strftime('%Y-%m-%d %H:%M:%S')
            })

    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)

    return JsonResponse({
        'has_evacuation': len(evacuation_notifications) > 0,
        'evacuations': evacuation_notifications
    })


@login_required
@role_required(['admin', 'safety_specialist'])
def evacuation_cancel(request, pk):
    """Отмена уведомления об эвакуации"""
    evacuation = get_object_or_404(EvacuationNotification, pk=pk)
    evacuation.is_active = False
    evacuation.save()

    messages.success(request, 'Уведомление об эвакуации отменено')
    return redirect('dashboard')


@login_required
@role_required(['admin', 'safety_specialist'])
def risk_resolve(request, pk):
    """Отметка критического риска как устраненного"""
    risk = get_object_or_404(Risk, pk=pk)

    if risk.level in ['high', 'critical']:
        # Устанавливаем более низкий уровень риска
        risk.level = 'medium'
        risk.save()

        # Создаем запись о мероприятии по снижению риска
        RiskMitigationMeasure.objects.create(
            risk=risk,
            description=f'Устранение критического риска ({risk.hazard.name})',
            status='completed',
            responsible_person=None if not hasattr(request.user, 'employee') else request.user.employee,
            completion_date=timezone.now()
        )

        messages.success(request, 'Критический риск отмечен как устраненный')
    else:
        messages.warning(request, 'Данный риск не является критическим или высоким')

    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({'status': 'success'})

    return redirect('risk_detail', pk=risk.pk)


@login_required
def critical_risks_api(request):
    """API для получения списка критических рисков"""
    critical_risks = Risk.objects.filter(level__in=['high', 'critical']).select_related('hazard', 'department')

    risks_data = []
    for risk in critical_risks:
        risks_data.append({
            'id': risk.id,
            'hazard_name': risk.hazard.name,
            'location': risk.location or '',
            'level': risk.level,
            'department': risk.department.name if risk.department else 'Не указано',
            'probability': float(risk.probability),
            'severity': risk.severity,
            'risk_score': risk.risk_score
        })

    return JsonResponse({
        'has_critical_risks': len(risks_data) > 0,
        'critical_risks': risks_data
    })


@login_required
def instruction_create_with_material(request):
    """Create an instruction with training materials and test"""
    if request.method == 'POST':
        # Process the instruction form
        instruction_form = InstructionForm(request.POST)
        if instruction_form.is_valid():
            instruction = instruction_form.save(commit=False)
            instruction.instructor = request.user
            instruction.save()

            # Handle the selected participants
            participant_ids = request.POST.getlist('participants')
            for employee_id in participant_ids:
                InstructionParticipant.objects.create(
                    instruction=instruction,
                    employee_id=employee_id,
                    status='assigned'  # New status for assigned but not completed
                )

            if participant_ids:
                notify_instruction_participants(
                    instruction=instruction,
                    notification_type='instruction_assigned',
                    title=f'Назначен инструктаж: {instruction.instruction_type.name}',
                    message=f'Вам назначен инструктаж "{instruction.instruction_type.name}". Дата проведения: {instruction.instruction_date.strftime("%d.%m.%Y %H:%M")}.'
                )

            # Check if materials are provided
            if 'has_materials' in request.POST:
                # Redirect to add materials page
                return redirect('instruction_add_materials', pk=instruction.pk)

            messages.success(request, 'Инструктаж успешно создан.')
            return redirect('instruction_list')
    else:
        instruction_form = InstructionForm()

    # List of employees for selection
    employees = Employee.objects.select_related('user', 'department').all()

    context = {
        'form': instruction_form,
        'employees': employees,
        'title': 'Создание инструктажа с материалами'
    }
    return render(request, 'instructions/instruction_form_with_material.html', context)


@login_required
def instruction_add_materials(request, pk):
    """Add materials to an instruction"""
    instruction = get_object_or_404(Instruction, pk=pk)

    # Get existing materials if any
    materials = InstructionMaterial.objects.filter(instruction=instruction).order_by('order')

    if request.method == 'POST':
        # Handle material form
        material_form = InstructionMaterialForm(request.POST, request.FILES)
        if material_form.is_valid():
            material = material_form.save(commit=False)
            material.instruction = instruction
            material.save()

            messages.success(request, 'Материал успешно добавлен.')

            # Check if the user wants to add more materials
            if 'add_more' in request.POST:
                return redirect('instruction_add_materials', pk=instruction.pk)
            # Check if the user wants to add a test
            elif 'add_test' in request.POST:
                return redirect('instruction_add_test', pk=instruction.pk)
            # Otherwise, redirect to instruction detail
            else:
                return redirect('instruction_detail', pk=instruction.pk)
    else:
        material_form = InstructionMaterialForm()

    context = {
        'instruction': instruction,
        'form': material_form,
        'materials': materials,
        'title': 'Добавление материалов к инструктажу'
    }
    return render(request, 'instructions/instruction_add_materials.html', context)


@login_required
def instruction_add_test(request, pk):
    """Add a test to an instruction"""
    instruction = get_object_or_404(Instruction, pk=pk)

    # Check if a test already exists
    try:
        test = instruction.test
        # Redirect to edit test if it exists
        return redirect('instruction_edit_test', pk=instruction.pk)
    except InstructionTest.DoesNotExist:
        test = None

    if request.method == 'POST':
        # Handle test form
        test_form = InstructionTestForm(request.POST)
        if test_form.is_valid():
            test = test_form.save(commit=False)
            test.instruction = instruction
            test.save()

            notify_instruction_participants(
                instruction=instruction,
                notification_type='test_available',
                title=f'Доступен тест по инструктажу: {instruction.instruction_type.name}',
                message=f'Для инструктажа "{instruction.instruction_type.name}" доступен тест "{test.title}". Пожалуйста, изучите материалы инструктажа и пройдите тест.'
            )

            messages.success(request, 'Тест успешно создан.')
            return redirect('instruction_add_test_question', test_id=test.pk)
    else:
        test_form = InstructionTestForm(initial={'title': f'Тест по инструктажу: {instruction.instruction_type.name}'})

    context = {
        'instruction': instruction,
        'form': test_form,
        'title': 'Создание теста к инструктажу'
    }
    return render(request, 'instructions/instruction_add_test.html', context)


def notify_instruction_participants(instruction, notification_type, title, message):
    """Отправка уведомлений всем участникам инструктажа"""
    participants = InstructionParticipant.objects.filter(instruction=instruction)

    for participant in participants:
        Notification.objects.create(
            user=participant.employee.user,
            title=title,
            message=message,
            notification_type=notification_type,
            related_entity_type='instruction',
            related_entity_id=instruction.id,
            is_read=False
        )
@login_required
def instruction_add_test_question(request, test_id):
    """Add questions to a test"""
    test = get_object_or_404(InstructionTest, pk=test_id)

    if request.method == 'POST':
        # Handle question form
        question_form = TestQuestionForm(request.POST)
        if question_form.is_valid():
            question = question_form.save(commit=False)
            question.test = test
            question.save()

            # Handle answer formset
            answer_formset = TestAnswerFormSet(request.POST, instance=question)
            if answer_formset.is_valid():
                answer_formset.save()

                messages.success(request, 'Вопрос успешно добавлен.')

                # Check if the user wants to add more questions
                if 'add_more' in request.POST:
                    return redirect('instruction_add_test_question', test_id=test.pk)
                # Otherwise, redirect to instruction detail
                else:
                    return redirect('instruction_detail', pk=test.instruction.pk)
    else:
        question_form = TestQuestionForm()
        answer_formset = TestAnswerFormSet()

    # Get existing questions for display
    questions = test.questions.all().order_by('order')

    context = {
        'test': test,
        'instruction': test.instruction,
        'form': question_form,
        'answer_formset': answer_formset,
        'questions': questions,
        'title': 'Добавление вопросов к тесту'
    }
    return render(request, 'instructions/instruction_add_test_question.html', context)


@login_required
def instruction_material_detail(request, pk):
    """View instruction material"""
    material = get_object_or_404(InstructionMaterial, pk=pk)
    instruction = material.instruction

    # Get all materials for navigation
    materials = InstructionMaterial.objects.filter(instruction=instruction).order_by('order')

    # Find previous and next materials
    previous_material = materials.filter(order__lt=material.order).order_by('-order').first()
    next_material = materials.filter(order__gt=material.order).order_by('order').first()

    context = {
        'material': material,
        'instruction': instruction,
        'materials': materials,
        'previous_material': previous_material,
        'next_material': next_material,
    }
    return render(request, 'instructions/instruction_material_detail.html', context)


@login_required
def instruction_study(request, pk):
    """Study instruction materials and take test"""
    instruction = get_object_or_404(Instruction, pk=pk)

    # Verify that the current user is a participant
    try:
        participant = InstructionParticipant.objects.get(
            instruction=instruction,
            employee=request.user.employee
        )
    except InstructionParticipant.DoesNotExist:
        messages.error(request, 'Вы не являетесь участником данного инструктажа.')
        return redirect('dashboard')

    # Get materials for this instruction
    materials = InstructionMaterial.objects.filter(instruction=instruction).order_by('order')

    # Check if a test exists
    try:
        test = instruction.test
        has_test = True
    except InstructionTest.DoesNotExist:
        test = None
        has_test = False

    # Check if user has already taken the test
    test_result = None
    if has_test:
        test_result = TestResult.objects.filter(
            test=test,
            employee=request.user.employee
        ).order_by('-start_time').first()

    context = {
        'instruction': instruction,
        'participant': participant,
        'materials': materials,
        'has_test': has_test,
        'test': test,
        'test_result': test_result
    }
    return render(request, 'instructions/instruction_study.html', context)


@login_required
def instruction_take_test(request, test_id):
    """Take the test for an instruction"""
    test = get_object_or_404(InstructionTest, pk=test_id)
    instruction = test.instruction

    # Verify that the current user is a participant
    try:
        participant = InstructionParticipant.objects.get(
            instruction=instruction,
            employee=request.user.employee
        )
    except InstructionParticipant.DoesNotExist:
        messages.error(request, 'Вы не являетесь участником данного инструктажа.')
        return redirect('dashboard')

    # Check if the user has already passed the test
    existing_result = TestResult.objects.filter(
        test=test,
        employee=request.user.employee,
        passed=True
    ).first()

    if existing_result:
        messages.info(request, 'Вы уже успешно прошли этот тест.')
        return redirect('instruction_study', pk=instruction.pk)

    # Create or get in-progress test result
    test_result, created = TestResult.objects.get_or_create(
        test=test,
        employee=request.user.employee,
        end_time__isnull=True,
        defaults={
            'max_score': test.questions.count(),
        }
    )

    if request.method == 'POST':
        # Process test submissions
        form = TestSubmissionForm(test, request.POST)

        if form.is_valid():
            # Calculate score
            correct_answers = 0
            total_questions = test.questions.count()

            for question in test.questions.all():
                field_name = f'question_{question.id}'
                if field_name in form.cleaned_data:
                    selected_answer_id = form.cleaned_data[field_name]
                    selected_answer = TestAnswer.objects.get(id=selected_answer_id)

                    # Record the submission
                    submission = TestAnswerSubmission.objects.create(
                        test_result=test_result,
                        question=question,
                        answer=selected_answer,
                        is_correct=selected_answer.is_correct
                    )

                    if selected_answer.is_correct:
                        correct_answers += 1

            # Update test result
            test_result.end_time = timezone.now()
            test_result.score = correct_answers

            if total_questions > 0:
                test_result.score_percent = (correct_answers / total_questions) * 100
                test_result.passed = test_result.score_percent >= test.passing_score
            else:
                test_result.score_percent = 0
                test_result.passed = False

            test_result.save()

            # Update participant status
            if test_result.passed:
                participant.status = 'completed'
                participant.test_result = test_result.score_percent
                participant.save()

                messages.success(request,
                                 f'Поздравляем! Вы успешно прошли тест с результатом {test_result.score_percent}%.')
            else:
                participant.status = 'failed'
                participant.test_result = test_result.score_percent
                participant.save()

                messages.error(request, f'К сожалению, вы не прошли тест. Ваш результат: {test_result.score_percent}%.')

            return redirect('instruction_test_result', result_id=test_result.pk)
    else:
        form = TestSubmissionForm(test)

    context = {
        'test': test,
        'instruction': instruction,
        'form': form,
        'time_limit': test.time_limit,
        'test_result': test_result
    }
    return render(request, 'instructions/instruction_take_test.html', context)


@login_required
def instruction_test_result(request, result_id):
    """View test result"""
    test_result = get_object_or_404(TestResult, pk=result_id)

    # Verify that the current user is the owner of the result
    if test_result.employee.user != request.user and not is_safety_specialist(request.user):
        messages.error(request, 'У вас нет доступа к этому результату теста.')
        return redirect('dashboard')

    # Get all answers and questions
    submissions = test_result.answer_submissions.all().select_related('question', 'answer')

    context = {
        'test_result': test_result,
        'test': test_result.test,
        'instruction': test_result.test.instruction,
        'submissions': submissions,
        'is_reviewer': is_safety_specialist(request.user),
    }
    return render(request, 'instructions/instruction_test_result.html', context)


@login_required
def instruction_test_results_list(request):
    """List all test results - only for safety specialists"""
    results = TestResult.objects.all().select_related(
        'test', 'test__instruction', 'employee', 'employee__user'
    ).order_by('-start_time')

    # Add filters
    employee_filter = request.GET.get('employee')
    if employee_filter:
        results = results.filter(employee_id=employee_filter)

    test_filter = request.GET.get('test')
    if test_filter:
        results = results.filter(test_id=test_filter)

    passed_filter = request.GET.get('passed')
    if passed_filter:
        results = results.filter(passed=(passed_filter == '1'))

    # Pagination
    paginator = Paginator(results, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'employee_filter': employee_filter,
        'test_filter': test_filter,
        'passed_filter': passed_filter,
    }
    return render(request, 'instructions/instruction_test_results_list.html', context)


@login_required
def instruction_review_test_result(request, result_id):
    """Review and update a test result - only for safety specialists"""
    test_result = get_object_or_404(TestResult, pk=result_id)

    if request.method == 'POST':
        # Update the result
        passed = 'passed' in request.POST
        notes = request.POST.get('reviewer_notes', '')

        test_result.passed = passed
        test_result.reviewer_notes = notes
        test_result.reviewed = True
        test_result.save()

        # Update participant status
        participant = InstructionParticipant.objects.get(
            instruction=test_result.test.instruction,
            employee=test_result.employee
        )

        if passed:
            participant.status = 'completed'
        else:
            participant.status = 'failed'

        participant.save()

        messages.success(request, 'Результат теста успешно обновлен.')
        return redirect('instruction_test_results_list')

    # Get all answers and questions
    submissions = test_result.answer_submissions.all().select_related('question', 'answer')

    context = {
        'test_result': test_result,
        'test': test_result.test,
        'instruction': test_result.test.instruction,
        'submissions': submissions,
    }
    return render(request, 'instructions/instruction_review_result.html', context)


# Helper function to check if user is a safety specialist
def is_safety_specialist(user):
    """Check if user is a safety specialist"""
    try:
        return user.employee.role in ['admin', 'safety_specialist']
    except:
        return False


# Update the existing instruction_detail view to include materials and test
@login_required
def instruction_detail(request, pk):
    instruction = get_object_or_404(Instruction, pk=pk)

    # Participants
    participants = InstructionParticipant.objects.filter(
        instruction=instruction
    ).select_related('employee', 'employee__user')

    # Materials
    materials = InstructionMaterial.objects.filter(instruction=instruction).order_by('order')

    # Test
    try:
        test = instruction.test
        has_test = True
    except InstructionTest.DoesNotExist:
        test = None
        has_test = False

    # Test results if test exists
    test_results = []
    if has_test:
        test_results = TestResult.objects.filter(test=test).select_related('employee', 'employee__user')

    # Check if current user is a participant
    is_participant = False
    user_test_result = None

    if hasattr(request.user, 'employee'):
        try:
            participant = InstructionParticipant.objects.get(
                instruction=instruction,
                employee=request.user.employee
            )
            is_participant = True

            # Get user's test result if available
            if has_test:
                user_test_result = TestResult.objects.filter(
                    test=test,
                    employee=request.user.employee
                ).order_by('-start_time').first()
        except InstructionParticipant.DoesNotExist:
            pass

    context = {
        'instruction': instruction,
        'participants': participants,
        'materials': materials,
        'has_test': has_test,
        'test': test,
        'test_results': test_results,
        'is_participant': is_participant,
        'user_test_result': user_test_result,
    }
    return render(request, 'instructions/instruction_detail.html', context)

@login_required
@role_required(['admin', 'medical_worker'])
def send_medical_notifications(request):
    """
    Представление для массовой отправки уведомлений о медосмотрах выбранным сотрудникам
    """
    if request.method != 'POST':
        return redirect('employee_list')

    employee_ids = request.POST.getlist('selected_employees')
    if not employee_ids:
        messages.error(request, 'Не выбраны сотрудники для отправки уведомлений.')
        return redirect('employee_list')

    notification_count = 0

    for employee_id in employee_ids:
        try:
            employee = Employee.objects.get(id=employee_id)

            # Создаем уведомление о необходимости пройти медосмотр
            notification = Notification.objects.create(
                user=employee.user,
                title='Необходимо пройти медицинский осмотр',
                message=f'Вам необходимо пройти медицинский осмотр. Пожалуйста, обратитесь в медицинский отдел для согласования даты.',
                notification_type='medical',
                related_entity_type='employee',
                related_entity_id=employee.id,
                is_read=False
            )

            notification_count += 1

        except Employee.DoesNotExist:
            continue

    messages.success(request, f'Уведомления успешно отправлены {notification_count} сотрудникам.')

    # Перенаправляем на ту же страницу
    return redirect('employee_list')

~21) asgi.py;~

"""
ASGI config for OrionWorkSec project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'OrionWorkSec.settings')

application = get_asgi_application()


~22) settings.py;~

"""
Django's settings for OrionWorkSec project.

Generated by 'django-admin startproject' using Django 5.1.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""
import os
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-11z&lc^m)&04npjr%iax8ux%%f*b*yeug17^^ldyr2t2347s(+'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'core',
    'import_export',
    'django_prometheus',
]

MIDDLEWARE = [
    'django_prometheus.middleware.PrometheusBeforeMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'core.middleware.RoleBasedAccessMiddleware',
    'django_prometheus.middleware.PrometheusAfterMiddleware',
]

ROOT_URLCONF = 'OrionWorkSec.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'OrionWorkSec.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'workplacesafety',
        'USER': 'postgres',
        'PASSWORD': '143952',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'ru-ru'

TIME_ZONE = 'Europe/Moscow'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = '/static/'
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Crispy Forms
CRISPY_ALLOWED_TEMPLATE_PACKS = "bootstrap5"
CRISPY_TEMPLATE_PACK = "bootstrap5"

# Login/Logout URLs
LOGIN_URL = 'login'
LOGIN_REDIRECT_URL = 'dashboard'
LOGOUT_REDIRECT_URL = 'login'

# Email settings
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.your-email-host.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = 'your-email@example.com'
EMAIL_HOST_PASSWORD = 'your-email-password'
DEFAULT_FROM_EMAIL = 'Орион <your-email@example.com>'

IMPORT_EXPORT_USE_TRANSACTIONS = True
IMPORT_EXPORT_SKIP_ADMIN_LOG = False
IMPORT_EXPORT_TMP_STORAGE_CLASS = 'import_export.tmp_storages.TempFolderStorage'

DATETIME_INPUT_FORMATS = ['%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M', '%Y-%m-%d', '%d.%m.%Y']
DATE_INPUT_FORMATS = ['%Y-%m-%d', '%d.%m.%Y']

IMPORT_EXPORT_FORMATS = [
    'import_export.formats.base_formats.CSV',
    'import_export.formats.base_formats.XLS',
    'import_export.formats.base_formats.XLSX',
    'import_export.formats.base_formats.JSON',
    'import_export.formats.base_formats.ODS',
    'import_export.formats.base_formats.HTML',
]
CRONJOBS = [
    ('0 8 * * *', 'core.cron_jobs.check_medical_exams'),
]

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': os.path.join(BASE_DIR, 'app.log'),
            'formatter': 'verbose',
        },
        'prometheus': {
            'level': 'INFO',
            'class': 'core.customlogger.PrometheusLogHandler'
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'prometheus'],
            'level': 'INFO',
            'propagate': True,
        },
    },
}

~23) urls.py;~

from django.conf import settings
from django.conf.urls.static import static
from django.urls import path, include
from django.contrib.auth import views as auth_views
from core import views
from core.admin_site import orion_admin_site
from django.contrib.auth.decorators import login_required
from functools import wraps
from django.shortcuts import redirect
from django.contrib import messages


def role_required(allowed_roles):

    def decorator(view_func):
        @wraps(view_func)
        def _wrapped_view(request, *args, **kwargs):
            if not request.user.is_authenticated:
                return redirect('login')

            try:
                user_role = request.user.employee.role
            except:
                user_role = 'employee'

            if user_role not in allowed_roles:
                messages.error(request, 'У вас нет доступа к данной функции.')
                return redirect('dashboard')

            return view_func(request, *args, **kwargs)

        return _wrapped_view

    return decorator


def view_only(view_func):
    """
    Декоратор, который разрешает только GET-запросы (только просмотр).
    При попытке изменения показывает сообщение об ошибке.
    """

    @wraps(view_func)
    def _wrapped_view(request, *args, **kwargs):
        if request.method != 'GET':
            messages.error(request, 'У вас есть доступ только для просмотра данного раздела.')
            current_url = request.path
            return redirect(current_url)
        return view_func(request, *args, **kwargs)

    return _wrapped_view


urlpatterns = [
    # Аутентификация
    path('', auth_views.LoginView.as_view(template_name='auth/login.html'), name='login'),
    path('logout/', views.logout_view, name='logout'),
    path('password_reset/', auth_views.PasswordResetView.as_view(template_name='auth/password_reset.html'),
         name='password_reset'),
    path('password_reset/done/',
         auth_views.PasswordResetDoneView.as_view(template_name='auth/password_reset_done.html'),
         name='password_reset_done'),
    path('reset/<uidb64>/<token>/',
         auth_views.PasswordResetConfirmView.as_view(template_name='auth/password_reset_confirm.html'),
         name='password_reset_confirm'),
    path('reset/done/', auth_views.PasswordResetCompleteView.as_view(template_name='auth/password_reset_complete.html'),
         name='password_reset_complete'),

    # Главная страница и поиск - доступ у всех авторизованных пользователей
    path('dashboard/', login_required(views.dashboard), name='dashboard'),
    path('search/', login_required(views.search), name='search'),

    # Мероприятия по снижению рисков
    path('risks/<int:risk_id>/mitigation/add/', login_required(views.risk_mitigation_add), name='risk_mitigation_add'),
    path('risks/mitigation/<int:pk>/update/', login_required(views.risk_mitigation_update), name='risk_mitigation_update'),
    path('risks/mitigation/<int:pk>/delete/', login_required(views.risk_mitigation_delete), name='risk_mitigation_delete'),

    # Профиль - доступ у всех авторизованных пользователей
    path('profile/', login_required(views.profile), name='profile'),

    # Настройки (только для администратора)
    path('settings/', login_required(role_required(['admin'])(views.settings)), name='settings'),

    # Задачи СИЗ
    # Просмотр списка - только определенные роли
    path('ppe/', login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.ppe_list)),
         name='ppe_list'),
    # Детали заявки - доступны всем (проверка внутри представления)
    path('ppe/<int:pk>/', login_required(views.ppe_detail), name='ppe_detail'),
    # Создание заявки - доступно всем
    path('ppe/create/', login_required(views.ppe_create), name='ppe_create'),
    # Редактирование, удаление и обработка - только определенные роли
    path('ppe/<int:pk>/update/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.ppe_update)),
         name='ppe_update'),
    path('ppe/<int:pk>/delete/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.ppe_delete)),
         name='ppe_delete'),
    path('ppe/<int:pk>/process/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.ppe_process)),
         name='ppe_process'),
    path('ppe/<int:pk>/issue/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.ppe_issue)),
         name='ppe_issue'),
    path('ppe/issue/<int:employee_id>/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.ppe_issue_employee)),
         name='ppe_issue_employee'),

    # Инструктажи
    path('instructions/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.instruction_list)),
         name='instruction_list'),
    path('instructions/<int:pk>/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.instruction_detail)),
         name='instruction_detail'),
    path('instructions/create/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.instruction_create)),
         name='instruction_create'),
    path('instructions/<int:pk>/update/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.instruction_update)),
         name='instruction_update'),
    path('instructions/<int:pk>/delete/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.instruction_delete)),
         name='instruction_delete'),

    # Документы - просмотр для всех, редактирование только для определенных ролей
    path('documents/', login_required(views.document_list), name='document_list'),
    path('documents/<int:pk>/', login_required(views.document_detail), name='document_detail'),
    path('documents/create/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.document_create)),
         name='document_create'),
    path('documents/<int:pk>/update/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.document_update)),
         name='document_update'),
    path('documents/<int:pk>/delete/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.document_delete)),
         name='document_delete'),

    # Риски - департамент только просмотр
    path('risks/', login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.risk_list)),
         name='risk_list'),
    path('risks/<int:pk>/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.risk_detail)),
         name='risk_detail'),
    path('risks/create/', login_required(role_required(['admin', 'safety_specialist'])(views.risk_create)),
         name='risk_create'),
    path('risks/<int:pk>/update/', login_required(role_required(['admin', 'safety_specialist'])(views.risk_update)),
         name='risk_update'),
    path('risks/<int:pk>/delete/', login_required(role_required(['admin', 'safety_specialist'])(views.risk_delete)),
         name='risk_delete'),
    path('risks/assessment/', login_required(role_required(['admin', 'safety_specialist'])(views.risk_assessment)),
         name='risk_assessment'),

    # Проверки - департамент только просмотр
    path('inspections/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.inspection_list)),
         name='inspection_list'),
    path('inspections/<int:pk>/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.inspection_detail)),
         name='inspection_detail'),
    path('inspections/create/', login_required(role_required(['admin', 'safety_specialist'])(views.inspection_create)),
         name='inspection_create'),
    path('inspections/<int:pk>/update/',
         login_required(role_required(['admin', 'safety_specialist'])(views.inspection_update)),
         name='inspection_update'),
    path('inspections/<int:pk>/delete/',
         login_required(role_required(['admin', 'safety_specialist'])(views.inspection_delete)),
         name='inspection_delete'),
    path('inspections/<int:pk>/complete/',
         login_required(role_required(['admin', 'safety_specialist'])(views.inspection_complete)),
         name='inspection_complete'),

    path('inspection_findings/create/<int:inspection_id>/',
         login_required(role_required(['admin', 'safety_specialist'])(views.inspection_finding_create)),
         name='inspection_finding_create'),
    path('inspection_findings/<int:pk>/update/',
         login_required(role_required(['admin', 'safety_specialist'])(views.inspection_finding_update)),
         name='inspection_finding_update'),
    path('inspection_findings/<int:pk>/delete/',
         login_required(role_required(['admin', 'safety_specialist'])(views.inspection_finding_delete)),
         name='inspection_finding_delete'),

    # Отчеты
    path('reports/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.report_list)),
         name='report_list'),
    path('reports/<str:report_type>/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.report_generate)),
         name='report_generate'),
    path('reports/custom/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.report_custom)),
         name='report_custom'),

    # URL для экспорта в различные форматы
    path('reports/inspection_results/excel/',
         views.inspection_results_report,
         {'format': 'excel'},
         name='inspection_results_excel'),

    path('reports/inspection_results/pdf/',
         views.inspection_results_report,
         {'format': 'pdf'},
         name='inspection_results_pdf'),

    # Сотрудники - специалист ОТ только просмотр
    path('employees/', login_required(
        role_required(['admin', 'department_head', 'medical_worker', 'safety_specialist'])(views.employee_list)),
         name='employee_list'),
    path('employees/<int:pk>/', login_required(
        role_required(['admin', 'department_head', 'medical_worker', 'safety_specialist'])(views.employee_detail)),
         name='employee_detail'),
    path('employees/create/', login_required(role_required(['admin', 'department_head'])(views.employee_create)),
         name='employee_create'),
    path('employees/<int:pk>/update/',
         login_required(role_required(['admin', 'department_head'])(views.employee_update)), name='employee_update'),
    path('employees/<int:pk>/delete/',
         login_required(role_required(['admin', 'department_head'])(views.employee_delete)), name='employee_delete'),

    path('reports/<str:report_type>/', views.report_generate, name='report_generate'),
    # Оборудование - департамент только просмотр
    path('equipment/', login_required(
        role_required(['admin', 'safety_specialist', 'department_head', 'technician'])(views.equipment_list)),
         name='equipment_list'),
    path('equipment/<int:pk>/', login_required(
        role_required(['admin', 'safety_specialist', 'department_head', 'technician'])(views.equipment_detail)),
         name='equipment_detail'),
    path('equipment/create/',
         login_required(role_required(['admin', 'safety_specialist', 'technician'])(views.equipment_create)),
         name='equipment_create'),
    path('equipment/<int:pk>/update/',
         login_required(role_required(['admin', 'safety_specialist', 'technician'])(views.equipment_update)),
         name='equipment_update'),
    path('equipment/<int:pk>/delete/',
         login_required(role_required(['admin', 'safety_specialist', 'technician'])(views.equipment_delete)),
         name='equipment_delete'),
    path('equipment/<int:pk>/maintenance/',
         login_required(role_required(['admin', 'safety_specialist', 'technician'])(views.equipment_maintenance)),
         name='equipment_maintenance'),

    # Обслуживание оборудования
    path('equipment_maintenance/',
         login_required(role_required(['admin', 'safety_specialist', 'technician'])(views.equipment_maintenance_list)),
         name='equipment_maintenance_list'),
    path('equipment_maintenance/<int:pk>/',
         login_required(role_required(['admin', 'safety_specialist', 'technician'])(views.maintenance_detail)),
         name='maintenance_detail'),
    path('equipment_maintenance/<int:pk>/update/',
         login_required(role_required(['admin', 'safety_specialist', 'technician'])(views.maintenance_update)),
         name='maintenance_update'),

    # Медицинские осмотры - только для админа и медика
    path('medical_exams/', login_required(role_required(['admin', 'medical_worker'])(views.medical_exam_list)),
         name='medical_exam_list'),
    path('medical_exams/<int:pk>/',
         login_required(role_required(['admin', 'medical_worker'])(views.medical_exam_detail)),
         name='medical_exam_detail'),
    path('medical_exams/create/', login_required(role_required(['admin', 'medical_worker'])(views.medical_exam_create)),
         name='medical_exam_create'),
    path('medical_exams/create/<int:employee_id>/',
         login_required(role_required(['admin', 'medical_worker'])(views.medical_exam_create)),
         name='medical_exam_create'),
    path('medical_exams/<int:pk>/update/',
         login_required(role_required(['admin', 'medical_worker'])(views.medical_exam_update)),
         name='medical_exam_update'),
    path('medical_exams/<int:pk>/delete/',
         login_required(role_required(['admin', 'medical_worker'])(views.medical_exam_delete)),
         name='medical_exam_delete'),

    # Уведомления - доступны всем авторизованным
    path('notifications/', login_required(views.notifications), name='notifications'),
    path('notifications/mark_read/<int:pk>/', login_required(views.notification_mark_read),
         name='notification_mark_read'),
    path('notifications/mark_all_read/', login_required(views.notifications_mark_all_read),
         name='notifications_mark_all_read'),

    # API для AJAX запросов
    path('api/stats/', login_required(views.api_stats), name='api_stats'),
    path('api/notifications/', login_required(views.api_notifications), name='api_notifications'),

    # Создание задач
    path('tasks/create/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.task_create)),
         name='task_create'),

    # Админ-панель - только для администратора
    path('admin/', orion_admin_site.urls),

    path('employees/send-medical-notifications/',
         login_required(role_required(['admin', 'medical_worker'])(views.send_medical_notifications)),
         name='send_medical_notifications'),

    path('prometheus/', include('django_prometheus.urls')),
    path('metrics/', views.metrics_view, name='metrics'),

    # Уведомления об эвакуации
    path('evacuation/create/',
         login_required(role_required(['admin', 'safety_specialist'])(views.evacuation_notification_create)),
         name='evacuation_create'),
    path('evacuation/cancel/<int:pk>/',
         login_required(role_required(['admin', 'safety_specialist'])(views.evacuation_cancel)),
         name='evacuation_cancel'),

    path('instructions/create-with-material/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.instruction_create_with_material)),
         name='instruction_create_with_material'),

    path('instructions/<int:pk>/add-materials/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.instruction_add_materials)),
         name='instruction_add_materials'),

    path('instructions/<int:pk>/add-test/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.instruction_add_test)),
         name='instruction_add_test'),

    path('instructions/test/<int:test_id>/add-question/',
         login_required(role_required(['admin', 'safety_specialist', 'department_head'])(views.instruction_add_test_question)),
         name='instruction_add_test_question'),

    path('instructions/material/<int:pk>/',
         login_required(views.instruction_material_detail),
         name='instruction_material_detail'),

    path('instructions/<int:pk>/study/',
         login_required(views.instruction_study),
         name='instruction_study'),

    path('instructions/test/<int:test_id>/take/',
         login_required(views.instruction_take_test),
         name='instruction_take_test'),

    path('instructions/test-result/<int:result_id>/',
         login_required(views.instruction_test_result),
         name='instruction_test_result'),

    path('instructions/test-results/',
         login_required(role_required(['admin', 'safety_specialist'])(views.instruction_test_results_list)),
         name='instruction_test_results_list'),

    path('instructions/test-result/<int:result_id>/review/',
         login_required(role_required(['admin', 'safety_specialist'])(views.instruction_review_test_result)),
         name='instruction_review_test_result'),

    # API для проверки уведомлений об эвакуации
    path('api/evacuation-check/', login_required(views.evacuation_check), name='api_evacuation_check'),

    # API для получения критических рисков
    path('api/critical-risks/', login_required(views.critical_risks_api), name='api_critical_risks'),

    # Управление критическими рисками
    path('risks/<int:pk>/resolve/',
         login_required(role_required(['admin', 'safety_specialist'])(views.risk_resolve)),
         name='risk_resolve'),
]
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

~24) wsgi.py;~

"""
WSGI config for OrionWorkSec project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'OrionWorkSec.settings')

application = get_wsgi_application()


